//
// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the protocol buffer compiler.
// Source: lightning.proto
//
import GRPC
import NIO
import NIOConcurrencyHelpers
import SwiftProtobuf


/// Lightning is the main RPC server of the daemon.
///
/// Usage: instantiate `Lnrpc_LightningClient`, then call methods of this protocol to make API calls.
internal protocol Lnrpc_LightningClientProtocol: GRPCClient {
  var serviceName: String { get }
  var interceptors: Lnrpc_LightningClientInterceptorFactoryProtocol? { get }

  func walletBalance(
    _ request: Lnrpc_WalletBalanceRequest,
    callOptions: CallOptions?
  ) -> UnaryCall<Lnrpc_WalletBalanceRequest, Lnrpc_WalletBalanceResponse>

  func channelBalance(
    _ request: Lnrpc_ChannelBalanceRequest,
    callOptions: CallOptions?
  ) -> UnaryCall<Lnrpc_ChannelBalanceRequest, Lnrpc_ChannelBalanceResponse>

  func getTransactions(
    _ request: Lnrpc_GetTransactionsRequest,
    callOptions: CallOptions?
  ) -> UnaryCall<Lnrpc_GetTransactionsRequest, Lnrpc_TransactionDetails>

  func estimateFee(
    _ request: Lnrpc_EstimateFeeRequest,
    callOptions: CallOptions?
  ) -> UnaryCall<Lnrpc_EstimateFeeRequest, Lnrpc_EstimateFeeResponse>

  func sendCoins(
    _ request: Lnrpc_SendCoinsRequest,
    callOptions: CallOptions?
  ) -> UnaryCall<Lnrpc_SendCoinsRequest, Lnrpc_SendCoinsResponse>

  func listUnspent(
    _ request: Lnrpc_ListUnspentRequest,
    callOptions: CallOptions?
  ) -> UnaryCall<Lnrpc_ListUnspentRequest, Lnrpc_ListUnspentResponse>

  func subscribeTransactions(
    _ request: Lnrpc_GetTransactionsRequest,
    callOptions: CallOptions?,
    handler: @escaping (Lnrpc_Transaction) -> Void
  ) -> ServerStreamingCall<Lnrpc_GetTransactionsRequest, Lnrpc_Transaction>

  func sendMany(
    _ request: Lnrpc_SendManyRequest,
    callOptions: CallOptions?
  ) -> UnaryCall<Lnrpc_SendManyRequest, Lnrpc_SendManyResponse>

  func newAddress(
    _ request: Lnrpc_NewAddressRequest,
    callOptions: CallOptions?
  ) -> UnaryCall<Lnrpc_NewAddressRequest, Lnrpc_NewAddressResponse>

  func signMessage(
    _ request: Lnrpc_SignMessageRequest,
    callOptions: CallOptions?
  ) -> UnaryCall<Lnrpc_SignMessageRequest, Lnrpc_SignMessageResponse>

  func verifyMessage(
    _ request: Lnrpc_VerifyMessageRequest,
    callOptions: CallOptions?
  ) -> UnaryCall<Lnrpc_VerifyMessageRequest, Lnrpc_VerifyMessageResponse>

  func connectPeer(
    _ request: Lnrpc_ConnectPeerRequest,
    callOptions: CallOptions?
  ) -> UnaryCall<Lnrpc_ConnectPeerRequest, Lnrpc_ConnectPeerResponse>

  func disconnectPeer(
    _ request: Lnrpc_DisconnectPeerRequest,
    callOptions: CallOptions?
  ) -> UnaryCall<Lnrpc_DisconnectPeerRequest, Lnrpc_DisconnectPeerResponse>

  func listPeers(
    _ request: Lnrpc_ListPeersRequest,
    callOptions: CallOptions?
  ) -> UnaryCall<Lnrpc_ListPeersRequest, Lnrpc_ListPeersResponse>

  func subscribePeerEvents(
    _ request: Lnrpc_PeerEventSubscription,
    callOptions: CallOptions?,
    handler: @escaping (Lnrpc_PeerEvent) -> Void
  ) -> ServerStreamingCall<Lnrpc_PeerEventSubscription, Lnrpc_PeerEvent>

  func getInfo(
    _ request: Lnrpc_GetInfoRequest,
    callOptions: CallOptions?
  ) -> UnaryCall<Lnrpc_GetInfoRequest, Lnrpc_GetInfoResponse>

  func getRecoveryInfo(
    _ request: Lnrpc_GetRecoveryInfoRequest,
    callOptions: CallOptions?
  ) -> UnaryCall<Lnrpc_GetRecoveryInfoRequest, Lnrpc_GetRecoveryInfoResponse>

  func pendingChannels(
    _ request: Lnrpc_PendingChannelsRequest,
    callOptions: CallOptions?
  ) -> UnaryCall<Lnrpc_PendingChannelsRequest, Lnrpc_PendingChannelsResponse>

  func listChannels(
    _ request: Lnrpc_ListChannelsRequest,
    callOptions: CallOptions?
  ) -> UnaryCall<Lnrpc_ListChannelsRequest, Lnrpc_ListChannelsResponse>

  func subscribeChannelEvents(
    _ request: Lnrpc_ChannelEventSubscription,
    callOptions: CallOptions?,
    handler: @escaping (Lnrpc_ChannelEventUpdate) -> Void
  ) -> ServerStreamingCall<Lnrpc_ChannelEventSubscription, Lnrpc_ChannelEventUpdate>

  func closedChannels(
    _ request: Lnrpc_ClosedChannelsRequest,
    callOptions: CallOptions?
  ) -> UnaryCall<Lnrpc_ClosedChannelsRequest, Lnrpc_ClosedChannelsResponse>

  func openChannelSync(
    _ request: Lnrpc_OpenChannelRequest,
    callOptions: CallOptions?
  ) -> UnaryCall<Lnrpc_OpenChannelRequest, Lnrpc_ChannelPoint>

  func openChannel(
    _ request: Lnrpc_OpenChannelRequest,
    callOptions: CallOptions?,
    handler: @escaping (Lnrpc_OpenStatusUpdate) -> Void
  ) -> ServerStreamingCall<Lnrpc_OpenChannelRequest, Lnrpc_OpenStatusUpdate>

  func batchOpenChannel(
    _ request: Lnrpc_BatchOpenChannelRequest,
    callOptions: CallOptions?
  ) -> UnaryCall<Lnrpc_BatchOpenChannelRequest, Lnrpc_BatchOpenChannelResponse>

  func fundingStateStep(
    _ request: Lnrpc_FundingTransitionMsg,
    callOptions: CallOptions?
  ) -> UnaryCall<Lnrpc_FundingTransitionMsg, Lnrpc_FundingStateStepResp>

  func channelAcceptor(
    callOptions: CallOptions?,
    handler: @escaping (Lnrpc_ChannelAcceptRequest) -> Void
  ) -> BidirectionalStreamingCall<Lnrpc_ChannelAcceptResponse, Lnrpc_ChannelAcceptRequest>

  func closeChannel(
    _ request: Lnrpc_CloseChannelRequest,
    callOptions: CallOptions?,
    handler: @escaping (Lnrpc_CloseStatusUpdate) -> Void
  ) -> ServerStreamingCall<Lnrpc_CloseChannelRequest, Lnrpc_CloseStatusUpdate>

  func abandonChannel(
    _ request: Lnrpc_AbandonChannelRequest,
    callOptions: CallOptions?
  ) -> UnaryCall<Lnrpc_AbandonChannelRequest, Lnrpc_AbandonChannelResponse>

  func sendPayment(
    callOptions: CallOptions?,
    handler: @escaping (Lnrpc_SendResponse) -> Void
  ) -> BidirectionalStreamingCall<Lnrpc_SendRequest, Lnrpc_SendResponse>

  func sendPaymentSync(
    _ request: Lnrpc_SendRequest,
    callOptions: CallOptions?
  ) -> UnaryCall<Lnrpc_SendRequest, Lnrpc_SendResponse>

  func sendToRoute(
    callOptions: CallOptions?,
    handler: @escaping (Lnrpc_SendResponse) -> Void
  ) -> BidirectionalStreamingCall<Lnrpc_SendToRouteRequest, Lnrpc_SendResponse>

  func sendToRouteSync(
    _ request: Lnrpc_SendToRouteRequest,
    callOptions: CallOptions?
  ) -> UnaryCall<Lnrpc_SendToRouteRequest, Lnrpc_SendResponse>

  func addInvoice(
    _ request: Lnrpc_Invoice,
    callOptions: CallOptions?
  ) -> UnaryCall<Lnrpc_Invoice, Lnrpc_AddInvoiceResponse>

  func listInvoices(
    _ request: Lnrpc_ListInvoiceRequest,
    callOptions: CallOptions?
  ) -> UnaryCall<Lnrpc_ListInvoiceRequest, Lnrpc_ListInvoiceResponse>

  func lookupInvoice(
    _ request: Lnrpc_PaymentHash,
    callOptions: CallOptions?
  ) -> UnaryCall<Lnrpc_PaymentHash, Lnrpc_Invoice>

  func subscribeInvoices(
    _ request: Lnrpc_InvoiceSubscription,
    callOptions: CallOptions?,
    handler: @escaping (Lnrpc_Invoice) -> Void
  ) -> ServerStreamingCall<Lnrpc_InvoiceSubscription, Lnrpc_Invoice>

  func decodePayReq(
    _ request: Lnrpc_PayReqString,
    callOptions: CallOptions?
  ) -> UnaryCall<Lnrpc_PayReqString, Lnrpc_PayReq>

  func listPayments(
    _ request: Lnrpc_ListPaymentsRequest,
    callOptions: CallOptions?
  ) -> UnaryCall<Lnrpc_ListPaymentsRequest, Lnrpc_ListPaymentsResponse>

  func deletePayment(
    _ request: Lnrpc_DeletePaymentRequest,
    callOptions: CallOptions?
  ) -> UnaryCall<Lnrpc_DeletePaymentRequest, Lnrpc_DeletePaymentResponse>

  func deleteAllPayments(
    _ request: Lnrpc_DeleteAllPaymentsRequest,
    callOptions: CallOptions?
  ) -> UnaryCall<Lnrpc_DeleteAllPaymentsRequest, Lnrpc_DeleteAllPaymentsResponse>

  func describeGraph(
    _ request: Lnrpc_ChannelGraphRequest,
    callOptions: CallOptions?
  ) -> UnaryCall<Lnrpc_ChannelGraphRequest, Lnrpc_ChannelGraph>

  func getNodeMetrics(
    _ request: Lnrpc_NodeMetricsRequest,
    callOptions: CallOptions?
  ) -> UnaryCall<Lnrpc_NodeMetricsRequest, Lnrpc_NodeMetricsResponse>

  func getChanInfo(
    _ request: Lnrpc_ChanInfoRequest,
    callOptions: CallOptions?
  ) -> UnaryCall<Lnrpc_ChanInfoRequest, Lnrpc_ChannelEdge>

  func getNodeInfo(
    _ request: Lnrpc_NodeInfoRequest,
    callOptions: CallOptions?
  ) -> UnaryCall<Lnrpc_NodeInfoRequest, Lnrpc_NodeInfo>

  func queryRoutes(
    _ request: Lnrpc_QueryRoutesRequest,
    callOptions: CallOptions?
  ) -> UnaryCall<Lnrpc_QueryRoutesRequest, Lnrpc_QueryRoutesResponse>

  func getNetworkInfo(
    _ request: Lnrpc_NetworkInfoRequest,
    callOptions: CallOptions?
  ) -> UnaryCall<Lnrpc_NetworkInfoRequest, Lnrpc_NetworkInfo>

  func stopDaemon(
    _ request: Lnrpc_StopRequest,
    callOptions: CallOptions?
  ) -> UnaryCall<Lnrpc_StopRequest, Lnrpc_StopResponse>

  func subscribeChannelGraph(
    _ request: Lnrpc_GraphTopologySubscription,
    callOptions: CallOptions?,
    handler: @escaping (Lnrpc_GraphTopologyUpdate) -> Void
  ) -> ServerStreamingCall<Lnrpc_GraphTopologySubscription, Lnrpc_GraphTopologyUpdate>

  func debugLevel(
    _ request: Lnrpc_DebugLevelRequest,
    callOptions: CallOptions?
  ) -> UnaryCall<Lnrpc_DebugLevelRequest, Lnrpc_DebugLevelResponse>

  func feeReport(
    _ request: Lnrpc_FeeReportRequest,
    callOptions: CallOptions?
  ) -> UnaryCall<Lnrpc_FeeReportRequest, Lnrpc_FeeReportResponse>

  func updateChannelPolicy(
    _ request: Lnrpc_PolicyUpdateRequest,
    callOptions: CallOptions?
  ) -> UnaryCall<Lnrpc_PolicyUpdateRequest, Lnrpc_PolicyUpdateResponse>

  func forwardingHistory(
    _ request: Lnrpc_ForwardingHistoryRequest,
    callOptions: CallOptions?
  ) -> UnaryCall<Lnrpc_ForwardingHistoryRequest, Lnrpc_ForwardingHistoryResponse>

  func exportChannelBackup(
    _ request: Lnrpc_ExportChannelBackupRequest,
    callOptions: CallOptions?
  ) -> UnaryCall<Lnrpc_ExportChannelBackupRequest, Lnrpc_ChannelBackup>

  func exportAllChannelBackups(
    _ request: Lnrpc_ChanBackupExportRequest,
    callOptions: CallOptions?
  ) -> UnaryCall<Lnrpc_ChanBackupExportRequest, Lnrpc_ChanBackupSnapshot>

  func verifyChanBackup(
    _ request: Lnrpc_ChanBackupSnapshot,
    callOptions: CallOptions?
  ) -> UnaryCall<Lnrpc_ChanBackupSnapshot, Lnrpc_VerifyChanBackupResponse>

  func restoreChannelBackups(
    _ request: Lnrpc_RestoreChanBackupRequest,
    callOptions: CallOptions?
  ) -> UnaryCall<Lnrpc_RestoreChanBackupRequest, Lnrpc_RestoreBackupResponse>

  func subscribeChannelBackups(
    _ request: Lnrpc_ChannelBackupSubscription,
    callOptions: CallOptions?,
    handler: @escaping (Lnrpc_ChanBackupSnapshot) -> Void
  ) -> ServerStreamingCall<Lnrpc_ChannelBackupSubscription, Lnrpc_ChanBackupSnapshot>

  func bakeMacaroon(
    _ request: Lnrpc_BakeMacaroonRequest,
    callOptions: CallOptions?
  ) -> UnaryCall<Lnrpc_BakeMacaroonRequest, Lnrpc_BakeMacaroonResponse>

  func listMacaroonIDs(
    _ request: Lnrpc_ListMacaroonIDsRequest,
    callOptions: CallOptions?
  ) -> UnaryCall<Lnrpc_ListMacaroonIDsRequest, Lnrpc_ListMacaroonIDsResponse>

  func deleteMacaroonID(
    _ request: Lnrpc_DeleteMacaroonIDRequest,
    callOptions: CallOptions?
  ) -> UnaryCall<Lnrpc_DeleteMacaroonIDRequest, Lnrpc_DeleteMacaroonIDResponse>

  func listPermissions(
    _ request: Lnrpc_ListPermissionsRequest,
    callOptions: CallOptions?
  ) -> UnaryCall<Lnrpc_ListPermissionsRequest, Lnrpc_ListPermissionsResponse>

  func checkMacaroonPermissions(
    _ request: Lnrpc_CheckMacPermRequest,
    callOptions: CallOptions?
  ) -> UnaryCall<Lnrpc_CheckMacPermRequest, Lnrpc_CheckMacPermResponse>

  func registerRPCMiddleware(
    callOptions: CallOptions?,
    handler: @escaping (Lnrpc_RPCMiddlewareRequest) -> Void
  ) -> BidirectionalStreamingCall<Lnrpc_RPCMiddlewareResponse, Lnrpc_RPCMiddlewareRequest>

  func sendCustomMessage(
    _ request: Lnrpc_SendCustomMessageRequest,
    callOptions: CallOptions?
  ) -> UnaryCall<Lnrpc_SendCustomMessageRequest, Lnrpc_SendCustomMessageResponse>

  func subscribeCustomMessages(
    _ request: Lnrpc_SubscribeCustomMessagesRequest,
    callOptions: CallOptions?,
    handler: @escaping (Lnrpc_CustomMessage) -> Void
  ) -> ServerStreamingCall<Lnrpc_SubscribeCustomMessagesRequest, Lnrpc_CustomMessage>

  func listAliases(
    _ request: Lnrpc_ListAliasesRequest,
    callOptions: CallOptions?
  ) -> UnaryCall<Lnrpc_ListAliasesRequest, Lnrpc_ListAliasesResponse>

  func lookupHtlcResolution(
    _ request: Lnrpc_LookupHtlcResolutionRequest,
    callOptions: CallOptions?
  ) -> UnaryCall<Lnrpc_LookupHtlcResolutionRequest, Lnrpc_LookupHtlcResolutionResponse>
}

extension Lnrpc_LightningClientProtocol {
  internal var serviceName: String {
    return "lnrpc.Lightning"
  }

  /// lncli: `walletbalance`
  ///WalletBalance returns total unspent outputs(confirmed and unconfirmed), all
  ///confirmed unspent outputs and all unconfirmed unspent outputs under control
  ///of the wallet.
  ///
  /// - Parameters:
  ///   - request: Request to send to WalletBalance.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  internal func walletBalance(
    _ request: Lnrpc_WalletBalanceRequest,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Lnrpc_WalletBalanceRequest, Lnrpc_WalletBalanceResponse> {
    return self.makeUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.walletBalance.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeWalletBalanceInterceptors() ?? []
    )
  }

  /// lncli: `channelbalance`
  ///ChannelBalance returns a report on the total funds across all open channels,
  ///categorized in local/remote, pending local/remote and unsettled local/remote
  ///balances.
  ///
  /// - Parameters:
  ///   - request: Request to send to ChannelBalance.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  internal func channelBalance(
    _ request: Lnrpc_ChannelBalanceRequest,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Lnrpc_ChannelBalanceRequest, Lnrpc_ChannelBalanceResponse> {
    return self.makeUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.channelBalance.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeChannelBalanceInterceptors() ?? []
    )
  }

  /// lncli: `listchaintxns`
  ///GetTransactions returns a list describing all the known transactions
  ///relevant to the wallet.
  ///
  /// - Parameters:
  ///   - request: Request to send to GetTransactions.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  internal func getTransactions(
    _ request: Lnrpc_GetTransactionsRequest,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Lnrpc_GetTransactionsRequest, Lnrpc_TransactionDetails> {
    return self.makeUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.getTransactions.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeGetTransactionsInterceptors() ?? []
    )
  }

  /// lncli: `estimatefee`
  ///EstimateFee asks the chain backend to estimate the fee rate and total fees
  ///for a transaction that pays to multiple specified outputs.
  ///
  ///When using REST, the `AddrToAmount` map type can be set by appending
  ///`&AddrToAmount[<address>]=<amount_to_send>` to the URL. Unfortunately this
  ///map type doesn't appear in the REST API documentation because of a bug in
  ///the grpc-gateway library.
  ///
  /// - Parameters:
  ///   - request: Request to send to EstimateFee.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  internal func estimateFee(
    _ request: Lnrpc_EstimateFeeRequest,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Lnrpc_EstimateFeeRequest, Lnrpc_EstimateFeeResponse> {
    return self.makeUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.estimateFee.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeEstimateFeeInterceptors() ?? []
    )
  }

  /// lncli: `sendcoins`
  ///SendCoins executes a request to send coins to a particular address. Unlike
  ///SendMany, this RPC call only allows creating a single output at a time. If
  ///neither target_conf, or sat_per_vbyte are set, then the internal wallet will
  ///consult its fee model to determine a fee for the default confirmation
  ///target.
  ///
  /// - Parameters:
  ///   - request: Request to send to SendCoins.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  internal func sendCoins(
    _ request: Lnrpc_SendCoinsRequest,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Lnrpc_SendCoinsRequest, Lnrpc_SendCoinsResponse> {
    return self.makeUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.sendCoins.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeSendCoinsInterceptors() ?? []
    )
  }

  /// lncli: `listunspent`
  ///Deprecated, use walletrpc.ListUnspent instead.
  ///
  ///ListUnspent returns a list of all utxos spendable by the wallet with a
  ///number of confirmations between the specified minimum and maximum.
  ///
  /// - Parameters:
  ///   - request: Request to send to ListUnspent.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  internal func listUnspent(
    _ request: Lnrpc_ListUnspentRequest,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Lnrpc_ListUnspentRequest, Lnrpc_ListUnspentResponse> {
    return self.makeUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.listUnspent.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeListUnspentInterceptors() ?? []
    )
  }

  ///
  ///SubscribeTransactions creates a uni-directional stream from the server to
  ///the client in which any newly discovered transactions relevant to the
  ///wallet are sent over.
  ///
  /// - Parameters:
  ///   - request: Request to send to SubscribeTransactions.
  ///   - callOptions: Call options.
  ///   - handler: A closure called when each response is received from the server.
  /// - Returns: A `ServerStreamingCall` with futures for the metadata and status.
  internal func subscribeTransactions(
    _ request: Lnrpc_GetTransactionsRequest,
    callOptions: CallOptions? = nil,
    handler: @escaping (Lnrpc_Transaction) -> Void
  ) -> ServerStreamingCall<Lnrpc_GetTransactionsRequest, Lnrpc_Transaction> {
    return self.makeServerStreamingCall(
      path: Lnrpc_LightningClientMetadata.Methods.subscribeTransactions.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeSubscribeTransactionsInterceptors() ?? [],
      handler: handler
    )
  }

  /// lncli: `sendmany`
  ///SendMany handles a request for a transaction that creates multiple specified
  ///outputs in parallel. If neither target_conf, or sat_per_vbyte are set, then
  ///the internal wallet will consult its fee model to determine a fee for the
  ///default confirmation target.
  ///
  /// - Parameters:
  ///   - request: Request to send to SendMany.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  internal func sendMany(
    _ request: Lnrpc_SendManyRequest,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Lnrpc_SendManyRequest, Lnrpc_SendManyResponse> {
    return self.makeUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.sendMany.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeSendManyInterceptors() ?? []
    )
  }

  /// lncli: `newaddress`
  ///NewAddress creates a new address under control of the local wallet.
  ///
  /// - Parameters:
  ///   - request: Request to send to NewAddress.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  internal func newAddress(
    _ request: Lnrpc_NewAddressRequest,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Lnrpc_NewAddressRequest, Lnrpc_NewAddressResponse> {
    return self.makeUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.newAddress.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeNewAddressInterceptors() ?? []
    )
  }

  /// lncli: `signmessage`
  ///SignMessage signs a message with this node's private key. The returned
  ///signature string is `zbase32` encoded and pubkey recoverable, meaning that
  ///only the message digest and signature are needed for verification.
  ///
  /// - Parameters:
  ///   - request: Request to send to SignMessage.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  internal func signMessage(
    _ request: Lnrpc_SignMessageRequest,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Lnrpc_SignMessageRequest, Lnrpc_SignMessageResponse> {
    return self.makeUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.signMessage.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeSignMessageInterceptors() ?? []
    )
  }

  /// lncli: `verifymessage`
  ///VerifyMessage verifies a signature over a message and recovers the signer's
  ///public key. The signature is only deemed valid if the recovered public key
  ///corresponds to a node key in the public Lightning network. The signature
  ///must be zbase32 encoded and signed by an active node in the resident node's
  ///channel database. In addition to returning the validity of the signature,
  ///VerifyMessage also returns the recovered pubkey from the signature.
  ///
  /// - Parameters:
  ///   - request: Request to send to VerifyMessage.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  internal func verifyMessage(
    _ request: Lnrpc_VerifyMessageRequest,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Lnrpc_VerifyMessageRequest, Lnrpc_VerifyMessageResponse> {
    return self.makeUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.verifyMessage.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeVerifyMessageInterceptors() ?? []
    )
  }

  /// lncli: `connect`
  ///ConnectPeer attempts to establish a connection to a remote peer. This is at
  ///the networking level, and is used for communication between nodes. This is
  ///distinct from establishing a channel with a peer.
  ///
  /// - Parameters:
  ///   - request: Request to send to ConnectPeer.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  internal func connectPeer(
    _ request: Lnrpc_ConnectPeerRequest,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Lnrpc_ConnectPeerRequest, Lnrpc_ConnectPeerResponse> {
    return self.makeUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.connectPeer.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeConnectPeerInterceptors() ?? []
    )
  }

  /// lncli: `disconnect`
  ///DisconnectPeer attempts to disconnect one peer from another identified by a
  ///given pubKey. In the case that we currently have a pending or active channel
  ///with the target peer, then this action will be not be allowed.
  ///
  /// - Parameters:
  ///   - request: Request to send to DisconnectPeer.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  internal func disconnectPeer(
    _ request: Lnrpc_DisconnectPeerRequest,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Lnrpc_DisconnectPeerRequest, Lnrpc_DisconnectPeerResponse> {
    return self.makeUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.disconnectPeer.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeDisconnectPeerInterceptors() ?? []
    )
  }

  /// lncli: `listpeers`
  ///ListPeers returns a verbose listing of all currently active peers.
  ///
  /// - Parameters:
  ///   - request: Request to send to ListPeers.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  internal func listPeers(
    _ request: Lnrpc_ListPeersRequest,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Lnrpc_ListPeersRequest, Lnrpc_ListPeersResponse> {
    return self.makeUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.listPeers.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeListPeersInterceptors() ?? []
    )
  }

  ///
  ///SubscribePeerEvents creates a uni-directional stream from the server to
  ///the client in which any events relevant to the state of peers are sent
  ///over. Events include peers going online and offline.
  ///
  /// - Parameters:
  ///   - request: Request to send to SubscribePeerEvents.
  ///   - callOptions: Call options.
  ///   - handler: A closure called when each response is received from the server.
  /// - Returns: A `ServerStreamingCall` with futures for the metadata and status.
  internal func subscribePeerEvents(
    _ request: Lnrpc_PeerEventSubscription,
    callOptions: CallOptions? = nil,
    handler: @escaping (Lnrpc_PeerEvent) -> Void
  ) -> ServerStreamingCall<Lnrpc_PeerEventSubscription, Lnrpc_PeerEvent> {
    return self.makeServerStreamingCall(
      path: Lnrpc_LightningClientMetadata.Methods.subscribePeerEvents.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeSubscribePeerEventsInterceptors() ?? [],
      handler: handler
    )
  }

  /// lncli: `getinfo`
  ///GetInfo returns general information concerning the lightning node including
  ///it's identity pubkey, alias, the chains it is connected to, and information
  ///concerning the number of open+pending channels.
  ///
  /// - Parameters:
  ///   - request: Request to send to GetInfo.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  internal func getInfo(
    _ request: Lnrpc_GetInfoRequest,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Lnrpc_GetInfoRequest, Lnrpc_GetInfoResponse> {
    return self.makeUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.getInfo.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeGetInfoInterceptors() ?? []
    )
  }

  ///* lncli: `getrecoveryinfo`
  ///GetRecoveryInfo returns information concerning the recovery mode including
  ///whether it's in a recovery mode, whether the recovery is finished, and the
  ///progress made so far.
  ///
  /// - Parameters:
  ///   - request: Request to send to GetRecoveryInfo.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  internal func getRecoveryInfo(
    _ request: Lnrpc_GetRecoveryInfoRequest,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Lnrpc_GetRecoveryInfoRequest, Lnrpc_GetRecoveryInfoResponse> {
    return self.makeUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.getRecoveryInfo.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeGetRecoveryInfoInterceptors() ?? []
    )
  }

  /// lncli: `pendingchannels`
  ///PendingChannels returns a list of all the channels that are currently
  ///considered "pending". A channel is pending if it has finished the funding
  ///workflow and is waiting for confirmations for the funding txn, or is in the
  ///process of closure, either initiated cooperatively or non-cooperatively.
  ///
  /// - Parameters:
  ///   - request: Request to send to PendingChannels.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  internal func pendingChannels(
    _ request: Lnrpc_PendingChannelsRequest,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Lnrpc_PendingChannelsRequest, Lnrpc_PendingChannelsResponse> {
    return self.makeUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.pendingChannels.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makePendingChannelsInterceptors() ?? []
    )
  }

  /// lncli: `listchannels`
  ///ListChannels returns a description of all the open channels that this node
  ///is a participant in.
  ///
  /// - Parameters:
  ///   - request: Request to send to ListChannels.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  internal func listChannels(
    _ request: Lnrpc_ListChannelsRequest,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Lnrpc_ListChannelsRequest, Lnrpc_ListChannelsResponse> {
    return self.makeUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.listChannels.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeListChannelsInterceptors() ?? []
    )
  }

  ///
  ///SubscribeChannelEvents creates a uni-directional stream from the server to
  ///the client in which any updates relevant to the state of the channels are
  ///sent over. Events include new active channels, inactive channels, and closed
  ///channels.
  ///
  /// - Parameters:
  ///   - request: Request to send to SubscribeChannelEvents.
  ///   - callOptions: Call options.
  ///   - handler: A closure called when each response is received from the server.
  /// - Returns: A `ServerStreamingCall` with futures for the metadata and status.
  internal func subscribeChannelEvents(
    _ request: Lnrpc_ChannelEventSubscription,
    callOptions: CallOptions? = nil,
    handler: @escaping (Lnrpc_ChannelEventUpdate) -> Void
  ) -> ServerStreamingCall<Lnrpc_ChannelEventSubscription, Lnrpc_ChannelEventUpdate> {
    return self.makeServerStreamingCall(
      path: Lnrpc_LightningClientMetadata.Methods.subscribeChannelEvents.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeSubscribeChannelEventsInterceptors() ?? [],
      handler: handler
    )
  }

  /// lncli: `closedchannels`
  ///ClosedChannels returns a description of all the closed channels that
  ///this node was a participant in.
  ///
  /// - Parameters:
  ///   - request: Request to send to ClosedChannels.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  internal func closedChannels(
    _ request: Lnrpc_ClosedChannelsRequest,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Lnrpc_ClosedChannelsRequest, Lnrpc_ClosedChannelsResponse> {
    return self.makeUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.closedChannels.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeClosedChannelsInterceptors() ?? []
    )
  }

  ///
  ///OpenChannelSync is a synchronous version of the OpenChannel RPC call. This
  ///call is meant to be consumed by clients to the REST proxy. As with all
  ///other sync calls, all byte slices are intended to be populated as hex
  ///encoded strings.
  ///
  /// - Parameters:
  ///   - request: Request to send to OpenChannelSync.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  internal func openChannelSync(
    _ request: Lnrpc_OpenChannelRequest,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Lnrpc_OpenChannelRequest, Lnrpc_ChannelPoint> {
    return self.makeUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.openChannelSync.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeOpenChannelSyncInterceptors() ?? []
    )
  }

  /// lncli: `openchannel`
  ///OpenChannel attempts to open a singly funded channel specified in the
  ///request to a remote peer. Users are able to specify a target number of
  ///blocks that the funding transaction should be confirmed in, or a manual fee
  ///rate to us for the funding transaction. If neither are specified, then a
  ///lax block confirmation target is used. Each OpenStatusUpdate will return
  ///the pending channel ID of the in-progress channel. Depending on the
  ///arguments specified in the OpenChannelRequest, this pending channel ID can
  ///then be used to manually progress the channel funding flow.
  ///
  /// - Parameters:
  ///   - request: Request to send to OpenChannel.
  ///   - callOptions: Call options.
  ///   - handler: A closure called when each response is received from the server.
  /// - Returns: A `ServerStreamingCall` with futures for the metadata and status.
  internal func openChannel(
    _ request: Lnrpc_OpenChannelRequest,
    callOptions: CallOptions? = nil,
    handler: @escaping (Lnrpc_OpenStatusUpdate) -> Void
  ) -> ServerStreamingCall<Lnrpc_OpenChannelRequest, Lnrpc_OpenStatusUpdate> {
    return self.makeServerStreamingCall(
      path: Lnrpc_LightningClientMetadata.Methods.openChannel.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeOpenChannelInterceptors() ?? [],
      handler: handler
    )
  }

  /// lncli: `batchopenchannel`
  ///BatchOpenChannel attempts to open multiple single-funded channels in a
  ///single transaction in an atomic way. This means either all channel open
  ///requests succeed at once or all attempts are aborted if any of them fail.
  ///This is the safer variant of using PSBTs to manually fund a batch of
  ///channels through the OpenChannel RPC.
  ///
  /// - Parameters:
  ///   - request: Request to send to BatchOpenChannel.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  internal func batchOpenChannel(
    _ request: Lnrpc_BatchOpenChannelRequest,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Lnrpc_BatchOpenChannelRequest, Lnrpc_BatchOpenChannelResponse> {
    return self.makeUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.batchOpenChannel.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeBatchOpenChannelInterceptors() ?? []
    )
  }

  ///
  ///FundingStateStep is an advanced funding related call that allows the caller
  ///to either execute some preparatory steps for a funding workflow, or
  ///manually progress a funding workflow. The primary way a funding flow is
  ///identified is via its pending channel ID. As an example, this method can be
  ///used to specify that we're expecting a funding flow for a particular
  ///pending channel ID, for which we need to use specific parameters.
  ///Alternatively, this can be used to interactively drive PSBT signing for
  ///funding for partially complete funding transactions.
  ///
  /// - Parameters:
  ///   - request: Request to send to FundingStateStep.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  internal func fundingStateStep(
    _ request: Lnrpc_FundingTransitionMsg,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Lnrpc_FundingTransitionMsg, Lnrpc_FundingStateStepResp> {
    return self.makeUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.fundingStateStep.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeFundingStateStepInterceptors() ?? []
    )
  }

  ///
  ///ChannelAcceptor dispatches a bi-directional streaming RPC in which
  ///OpenChannel requests are sent to the client and the client responds with
  ///a boolean that tells LND whether or not to accept the channel. This allows
  ///node operators to specify their own criteria for accepting inbound channels
  ///through a single persistent connection.
  ///
  /// Callers should use the `send` method on the returned object to send messages
  /// to the server. The caller should send an `.end` after the final message has been sent.
  ///
  /// - Parameters:
  ///   - callOptions: Call options.
  ///   - handler: A closure called when each response is received from the server.
  /// - Returns: A `ClientStreamingCall` with futures for the metadata and status.
  internal func channelAcceptor(
    callOptions: CallOptions? = nil,
    handler: @escaping (Lnrpc_ChannelAcceptRequest) -> Void
  ) -> BidirectionalStreamingCall<Lnrpc_ChannelAcceptResponse, Lnrpc_ChannelAcceptRequest> {
    return self.makeBidirectionalStreamingCall(
      path: Lnrpc_LightningClientMetadata.Methods.channelAcceptor.path,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeChannelAcceptorInterceptors() ?? [],
      handler: handler
    )
  }

  /// lncli: `closechannel`
  ///CloseChannel attempts to close an active channel identified by its channel
  ///outpoint (ChannelPoint). The actions of this method can additionally be
  ///augmented to attempt a force close after a timeout period in the case of an
  ///inactive peer. If a non-force close (cooperative closure) is requested,
  ///then the user can specify either a target number of blocks until the
  ///closure transaction is confirmed, or a manual fee rate. If neither are
  ///specified, then a default lax, block confirmation target is used.
  ///
  /// - Parameters:
  ///   - request: Request to send to CloseChannel.
  ///   - callOptions: Call options.
  ///   - handler: A closure called when each response is received from the server.
  /// - Returns: A `ServerStreamingCall` with futures for the metadata and status.
  internal func closeChannel(
    _ request: Lnrpc_CloseChannelRequest,
    callOptions: CallOptions? = nil,
    handler: @escaping (Lnrpc_CloseStatusUpdate) -> Void
  ) -> ServerStreamingCall<Lnrpc_CloseChannelRequest, Lnrpc_CloseStatusUpdate> {
    return self.makeServerStreamingCall(
      path: Lnrpc_LightningClientMetadata.Methods.closeChannel.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeCloseChannelInterceptors() ?? [],
      handler: handler
    )
  }

  /// lncli: `abandonchannel`
  ///AbandonChannel removes all channel state from the database except for a
  ///close summary. This method can be used to get rid of permanently unusable
  ///channels due to bugs fixed in newer versions of lnd. This method can also be
  ///used to remove externally funded channels where the funding transaction was
  ///never broadcast. Only available for non-externally funded channels in dev
  ///build.
  ///
  /// - Parameters:
  ///   - request: Request to send to AbandonChannel.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  internal func abandonChannel(
    _ request: Lnrpc_AbandonChannelRequest,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Lnrpc_AbandonChannelRequest, Lnrpc_AbandonChannelResponse> {
    return self.makeUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.abandonChannel.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeAbandonChannelInterceptors() ?? []
    )
  }

  /// lncli: `sendpayment`
  ///Deprecated, use routerrpc.SendPaymentV2. SendPayment dispatches a
  ///bi-directional streaming RPC for sending payments through the Lightning
  ///Network. A single RPC invocation creates a persistent bi-directional
  ///stream allowing clients to rapidly send payments through the Lightning
  ///Network with a single persistent connection.
  ///
  /// Callers should use the `send` method on the returned object to send messages
  /// to the server. The caller should send an `.end` after the final message has been sent.
  ///
  /// - Parameters:
  ///   - callOptions: Call options.
  ///   - handler: A closure called when each response is received from the server.
  /// - Returns: A `ClientStreamingCall` with futures for the metadata and status.
  internal func sendPayment(
    callOptions: CallOptions? = nil,
    handler: @escaping (Lnrpc_SendResponse) -> Void
  ) -> BidirectionalStreamingCall<Lnrpc_SendRequest, Lnrpc_SendResponse> {
    return self.makeBidirectionalStreamingCall(
      path: Lnrpc_LightningClientMetadata.Methods.sendPayment.path,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeSendPaymentInterceptors() ?? [],
      handler: handler
    )
  }

  ///
  ///SendPaymentSync is the synchronous non-streaming version of SendPayment.
  ///This RPC is intended to be consumed by clients of the REST proxy.
  ///Additionally, this RPC expects the destination's public key and the payment
  ///hash (if any) to be encoded as hex strings.
  ///
  /// - Parameters:
  ///   - request: Request to send to SendPaymentSync.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  internal func sendPaymentSync(
    _ request: Lnrpc_SendRequest,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Lnrpc_SendRequest, Lnrpc_SendResponse> {
    return self.makeUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.sendPaymentSync.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeSendPaymentSyncInterceptors() ?? []
    )
  }

  /// lncli: `sendtoroute`
  ///Deprecated, use routerrpc.SendToRouteV2. SendToRoute is a bi-directional
  ///streaming RPC for sending payment through the Lightning Network. This
  ///method differs from SendPayment in that it allows users to specify a full
  ///route manually. This can be used for things like rebalancing, and atomic
  ///swaps.
  ///
  /// Callers should use the `send` method on the returned object to send messages
  /// to the server. The caller should send an `.end` after the final message has been sent.
  ///
  /// - Parameters:
  ///   - callOptions: Call options.
  ///   - handler: A closure called when each response is received from the server.
  /// - Returns: A `ClientStreamingCall` with futures for the metadata and status.
  internal func sendToRoute(
    callOptions: CallOptions? = nil,
    handler: @escaping (Lnrpc_SendResponse) -> Void
  ) -> BidirectionalStreamingCall<Lnrpc_SendToRouteRequest, Lnrpc_SendResponse> {
    return self.makeBidirectionalStreamingCall(
      path: Lnrpc_LightningClientMetadata.Methods.sendToRoute.path,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeSendToRouteInterceptors() ?? [],
      handler: handler
    )
  }

  ///
  ///SendToRouteSync is a synchronous version of SendToRoute. It Will block
  ///until the payment either fails or succeeds.
  ///
  /// - Parameters:
  ///   - request: Request to send to SendToRouteSync.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  internal func sendToRouteSync(
    _ request: Lnrpc_SendToRouteRequest,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Lnrpc_SendToRouteRequest, Lnrpc_SendResponse> {
    return self.makeUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.sendToRouteSync.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeSendToRouteSyncInterceptors() ?? []
    )
  }

  /// lncli: `addinvoice`
  ///AddInvoice attempts to add a new invoice to the invoice database. Any
  ///duplicated invoices are rejected, therefore all invoices *must* have a
  ///unique payment preimage.
  ///
  /// - Parameters:
  ///   - request: Request to send to AddInvoice.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  internal func addInvoice(
    _ request: Lnrpc_Invoice,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Lnrpc_Invoice, Lnrpc_AddInvoiceResponse> {
    return self.makeUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.addInvoice.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeAddInvoiceInterceptors() ?? []
    )
  }

  /// lncli: `listinvoices`
  ///ListInvoices returns a list of all the invoices currently stored within the
  ///database. Any active debug invoices are ignored. It has full support for
  ///paginated responses, allowing users to query for specific invoices through
  ///their add_index. This can be done by using either the first_index_offset or
  ///last_index_offset fields included in the response as the index_offset of the
  ///next request. By default, the first 100 invoices created will be returned.
  ///Backwards pagination is also supported through the Reversed flag.
  ///
  /// - Parameters:
  ///   - request: Request to send to ListInvoices.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  internal func listInvoices(
    _ request: Lnrpc_ListInvoiceRequest,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Lnrpc_ListInvoiceRequest, Lnrpc_ListInvoiceResponse> {
    return self.makeUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.listInvoices.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeListInvoicesInterceptors() ?? []
    )
  }

  /// lncli: `lookupinvoice`
  ///LookupInvoice attempts to look up an invoice according to its payment hash.
  ///The passed payment hash *must* be exactly 32 bytes, if not, an error is
  ///returned.
  ///
  /// - Parameters:
  ///   - request: Request to send to LookupInvoice.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  internal func lookupInvoice(
    _ request: Lnrpc_PaymentHash,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Lnrpc_PaymentHash, Lnrpc_Invoice> {
    return self.makeUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.lookupInvoice.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeLookupInvoiceInterceptors() ?? []
    )
  }

  ///
  ///SubscribeInvoices returns a uni-directional stream (server -> client) for
  ///notifying the client of newly added/settled invoices. The caller can
  ///optionally specify the add_index and/or the settle_index. If the add_index
  ///is specified, then we'll first start by sending add invoice events for all
  ///invoices with an add_index greater than the specified value. If the
  ///settle_index is specified, the next, we'll send out all settle events for
  ///invoices with a settle_index greater than the specified value. One or both
  ///of these fields can be set. If no fields are set, then we'll only send out
  ///the latest add/settle events.
  ///
  /// - Parameters:
  ///   - request: Request to send to SubscribeInvoices.
  ///   - callOptions: Call options.
  ///   - handler: A closure called when each response is received from the server.
  /// - Returns: A `ServerStreamingCall` with futures for the metadata and status.
  internal func subscribeInvoices(
    _ request: Lnrpc_InvoiceSubscription,
    callOptions: CallOptions? = nil,
    handler: @escaping (Lnrpc_Invoice) -> Void
  ) -> ServerStreamingCall<Lnrpc_InvoiceSubscription, Lnrpc_Invoice> {
    return self.makeServerStreamingCall(
      path: Lnrpc_LightningClientMetadata.Methods.subscribeInvoices.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeSubscribeInvoicesInterceptors() ?? [],
      handler: handler
    )
  }

  /// lncli: `decodepayreq`
  ///DecodePayReq takes an encoded payment request string and attempts to decode
  ///it, returning a full description of the conditions encoded within the
  ///payment request.
  ///
  /// - Parameters:
  ///   - request: Request to send to DecodePayReq.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  internal func decodePayReq(
    _ request: Lnrpc_PayReqString,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Lnrpc_PayReqString, Lnrpc_PayReq> {
    return self.makeUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.decodePayReq.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeDecodePayReqInterceptors() ?? []
    )
  }

  /// lncli: `listpayments`
  ///ListPayments returns a list of all outgoing payments.
  ///
  /// - Parameters:
  ///   - request: Request to send to ListPayments.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  internal func listPayments(
    _ request: Lnrpc_ListPaymentsRequest,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Lnrpc_ListPaymentsRequest, Lnrpc_ListPaymentsResponse> {
    return self.makeUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.listPayments.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeListPaymentsInterceptors() ?? []
    )
  }

  ///
  ///DeletePayment deletes an outgoing payment from DB. Note that it will not
  ///attempt to delete an In-Flight payment, since that would be unsafe.
  ///
  /// - Parameters:
  ///   - request: Request to send to DeletePayment.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  internal func deletePayment(
    _ request: Lnrpc_DeletePaymentRequest,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Lnrpc_DeletePaymentRequest, Lnrpc_DeletePaymentResponse> {
    return self.makeUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.deletePayment.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeDeletePaymentInterceptors() ?? []
    )
  }

  ///
  ///DeleteAllPayments deletes all outgoing payments from DB. Note that it will
  ///not attempt to delete In-Flight payments, since that would be unsafe.
  ///
  /// - Parameters:
  ///   - request: Request to send to DeleteAllPayments.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  internal func deleteAllPayments(
    _ request: Lnrpc_DeleteAllPaymentsRequest,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Lnrpc_DeleteAllPaymentsRequest, Lnrpc_DeleteAllPaymentsResponse> {
    return self.makeUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.deleteAllPayments.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeDeleteAllPaymentsInterceptors() ?? []
    )
  }

  /// lncli: `describegraph`
  ///DescribeGraph returns a description of the latest graph state from the
  ///point of view of the node. The graph information is partitioned into two
  ///components: all the nodes/vertexes, and all the edges that connect the
  ///vertexes themselves. As this is a directed graph, the edges also contain
  ///the node directional specific routing policy which includes: the time lock
  ///delta, fee information, etc.
  ///
  /// - Parameters:
  ///   - request: Request to send to DescribeGraph.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  internal func describeGraph(
    _ request: Lnrpc_ChannelGraphRequest,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Lnrpc_ChannelGraphRequest, Lnrpc_ChannelGraph> {
    return self.makeUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.describeGraph.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeDescribeGraphInterceptors() ?? []
    )
  }

  /// lncli: `getnodemetrics`
  ///GetNodeMetrics returns node metrics calculated from the graph. Currently
  ///the only supported metric is betweenness centrality of individual nodes.
  ///
  /// - Parameters:
  ///   - request: Request to send to GetNodeMetrics.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  internal func getNodeMetrics(
    _ request: Lnrpc_NodeMetricsRequest,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Lnrpc_NodeMetricsRequest, Lnrpc_NodeMetricsResponse> {
    return self.makeUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.getNodeMetrics.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeGetNodeMetricsInterceptors() ?? []
    )
  }

  /// lncli: `getchaninfo`
  ///GetChanInfo returns the latest authenticated network announcement for the
  ///given channel identified by its channel ID: an 8-byte integer which
  ///uniquely identifies the location of transaction's funding output within the
  ///blockchain.
  ///
  /// - Parameters:
  ///   - request: Request to send to GetChanInfo.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  internal func getChanInfo(
    _ request: Lnrpc_ChanInfoRequest,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Lnrpc_ChanInfoRequest, Lnrpc_ChannelEdge> {
    return self.makeUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.getChanInfo.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeGetChanInfoInterceptors() ?? []
    )
  }

  /// lncli: `getnodeinfo`
  ///GetNodeInfo returns the latest advertised, aggregated, and authenticated
  ///channel information for the specified node identified by its public key.
  ///
  /// - Parameters:
  ///   - request: Request to send to GetNodeInfo.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  internal func getNodeInfo(
    _ request: Lnrpc_NodeInfoRequest,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Lnrpc_NodeInfoRequest, Lnrpc_NodeInfo> {
    return self.makeUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.getNodeInfo.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeGetNodeInfoInterceptors() ?? []
    )
  }

  /// lncli: `queryroutes`
  ///QueryRoutes attempts to query the daemon's Channel Router for a possible
  ///route to a target destination capable of carrying a specific amount of
  ///satoshis. The returned route contains the full details required to craft and
  ///send an HTLC, also including the necessary information that should be
  ///present within the Sphinx packet encapsulated within the HTLC.
  ///
  ///When using REST, the `dest_custom_records` map type can be set by appending
  ///`&dest_custom_records[<record_number>]=<record_data_base64_url_encoded>`
  ///to the URL. Unfortunately this map type doesn't appear in the REST API
  ///documentation because of a bug in the grpc-gateway library.
  ///
  /// - Parameters:
  ///   - request: Request to send to QueryRoutes.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  internal func queryRoutes(
    _ request: Lnrpc_QueryRoutesRequest,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Lnrpc_QueryRoutesRequest, Lnrpc_QueryRoutesResponse> {
    return self.makeUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.queryRoutes.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeQueryRoutesInterceptors() ?? []
    )
  }

  /// lncli: `getnetworkinfo`
  ///GetNetworkInfo returns some basic stats about the known channel graph from
  ///the point of view of the node.
  ///
  /// - Parameters:
  ///   - request: Request to send to GetNetworkInfo.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  internal func getNetworkInfo(
    _ request: Lnrpc_NetworkInfoRequest,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Lnrpc_NetworkInfoRequest, Lnrpc_NetworkInfo> {
    return self.makeUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.getNetworkInfo.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeGetNetworkInfoInterceptors() ?? []
    )
  }

  /// lncli: `stop`
  ///StopDaemon will send a shutdown request to the interrupt handler, triggering
  ///a graceful shutdown of the daemon.
  ///
  /// - Parameters:
  ///   - request: Request to send to StopDaemon.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  internal func stopDaemon(
    _ request: Lnrpc_StopRequest,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Lnrpc_StopRequest, Lnrpc_StopResponse> {
    return self.makeUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.stopDaemon.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeStopDaemonInterceptors() ?? []
    )
  }

  ///
  ///SubscribeChannelGraph launches a streaming RPC that allows the caller to
  ///receive notifications upon any changes to the channel graph topology from
  ///the point of view of the responding node. Events notified include: new
  ///nodes coming online, nodes updating their authenticated attributes, new
  ///channels being advertised, updates in the routing policy for a directional
  ///channel edge, and when channels are closed on-chain.
  ///
  /// - Parameters:
  ///   - request: Request to send to SubscribeChannelGraph.
  ///   - callOptions: Call options.
  ///   - handler: A closure called when each response is received from the server.
  /// - Returns: A `ServerStreamingCall` with futures for the metadata and status.
  internal func subscribeChannelGraph(
    _ request: Lnrpc_GraphTopologySubscription,
    callOptions: CallOptions? = nil,
    handler: @escaping (Lnrpc_GraphTopologyUpdate) -> Void
  ) -> ServerStreamingCall<Lnrpc_GraphTopologySubscription, Lnrpc_GraphTopologyUpdate> {
    return self.makeServerStreamingCall(
      path: Lnrpc_LightningClientMetadata.Methods.subscribeChannelGraph.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeSubscribeChannelGraphInterceptors() ?? [],
      handler: handler
    )
  }

  /// lncli: `debuglevel`
  ///DebugLevel allows a caller to programmatically set the logging verbosity of
  ///lnd. The logging can be targeted according to a coarse daemon-wide logging
  ///level, or in a granular fashion to specify the logging for a target
  ///sub-system.
  ///
  /// - Parameters:
  ///   - request: Request to send to DebugLevel.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  internal func debugLevel(
    _ request: Lnrpc_DebugLevelRequest,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Lnrpc_DebugLevelRequest, Lnrpc_DebugLevelResponse> {
    return self.makeUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.debugLevel.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeDebugLevelInterceptors() ?? []
    )
  }

  /// lncli: `feereport`
  ///FeeReport allows the caller to obtain a report detailing the current fee
  ///schedule enforced by the node globally for each channel.
  ///
  /// - Parameters:
  ///   - request: Request to send to FeeReport.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  internal func feeReport(
    _ request: Lnrpc_FeeReportRequest,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Lnrpc_FeeReportRequest, Lnrpc_FeeReportResponse> {
    return self.makeUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.feeReport.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeFeeReportInterceptors() ?? []
    )
  }

  /// lncli: `updatechanpolicy`
  ///UpdateChannelPolicy allows the caller to update the fee schedule and
  ///channel policies for all channels globally, or a particular channel.
  ///
  /// - Parameters:
  ///   - request: Request to send to UpdateChannelPolicy.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  internal func updateChannelPolicy(
    _ request: Lnrpc_PolicyUpdateRequest,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Lnrpc_PolicyUpdateRequest, Lnrpc_PolicyUpdateResponse> {
    return self.makeUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.updateChannelPolicy.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeUpdateChannelPolicyInterceptors() ?? []
    )
  }

  /// lncli: `fwdinghistory`
  ///ForwardingHistory allows the caller to query the htlcswitch for a record of
  ///all HTLCs forwarded within the target time range, and integer offset
  ///within that time range, for a maximum number of events. If no maximum number
  ///of events is specified, up to 100 events will be returned. If no time-range
  ///is specified, then events will be returned in the order that they occured.
  ///
  ///A list of forwarding events are returned. The size of each forwarding event
  ///is 40 bytes, and the max message size able to be returned in gRPC is 4 MiB.
  ///As a result each message can only contain 50k entries. Each response has
  ///the index offset of the last entry. The index offset can be provided to the
  ///request to allow the caller to skip a series of records.
  ///
  /// - Parameters:
  ///   - request: Request to send to ForwardingHistory.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  internal func forwardingHistory(
    _ request: Lnrpc_ForwardingHistoryRequest,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Lnrpc_ForwardingHistoryRequest, Lnrpc_ForwardingHistoryResponse> {
    return self.makeUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.forwardingHistory.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeForwardingHistoryInterceptors() ?? []
    )
  }

  /// lncli: `exportchanbackup`
  ///ExportChannelBackup attempts to return an encrypted static channel backup
  ///for the target channel identified by it channel point. The backup is
  ///encrypted with a key generated from the aezeed seed of the user. The
  ///returned backup can either be restored using the RestoreChannelBackup
  ///method once lnd is running, or via the InitWallet and UnlockWallet methods
  ///from the WalletUnlocker service.
  ///
  /// - Parameters:
  ///   - request: Request to send to ExportChannelBackup.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  internal func exportChannelBackup(
    _ request: Lnrpc_ExportChannelBackupRequest,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Lnrpc_ExportChannelBackupRequest, Lnrpc_ChannelBackup> {
    return self.makeUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.exportChannelBackup.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeExportChannelBackupInterceptors() ?? []
    )
  }

  ///
  ///ExportAllChannelBackups returns static channel backups for all existing
  ///channels known to lnd. A set of regular singular static channel backups for
  ///each channel are returned. Additionally, a multi-channel backup is returned
  ///as well, which contains a single encrypted blob containing the backups of
  ///each channel.
  ///
  /// - Parameters:
  ///   - request: Request to send to ExportAllChannelBackups.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  internal func exportAllChannelBackups(
    _ request: Lnrpc_ChanBackupExportRequest,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Lnrpc_ChanBackupExportRequest, Lnrpc_ChanBackupSnapshot> {
    return self.makeUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.exportAllChannelBackups.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeExportAllChannelBackupsInterceptors() ?? []
    )
  }

  ///
  ///VerifyChanBackup allows a caller to verify the integrity of a channel backup
  ///snapshot. This method will accept either a packed Single or a packed Multi.
  ///Specifying both will result in an error.
  ///
  /// - Parameters:
  ///   - request: Request to send to VerifyChanBackup.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  internal func verifyChanBackup(
    _ request: Lnrpc_ChanBackupSnapshot,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Lnrpc_ChanBackupSnapshot, Lnrpc_VerifyChanBackupResponse> {
    return self.makeUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.verifyChanBackup.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeVerifyChanBackupInterceptors() ?? []
    )
  }

  /// lncli: `restorechanbackup`
  ///RestoreChannelBackups accepts a set of singular channel backups, or a
  ///single encrypted multi-chan backup and attempts to recover any funds
  ///remaining within the channel. If we are able to unpack the backup, then the
  ///new channel will be shown under listchannels, as well as pending channels.
  ///
  /// - Parameters:
  ///   - request: Request to send to RestoreChannelBackups.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  internal func restoreChannelBackups(
    _ request: Lnrpc_RestoreChanBackupRequest,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Lnrpc_RestoreChanBackupRequest, Lnrpc_RestoreBackupResponse> {
    return self.makeUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.restoreChannelBackups.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeRestoreChannelBackupsInterceptors() ?? []
    )
  }

  ///
  ///SubscribeChannelBackups allows a client to sub-subscribe to the most up to
  ///date information concerning the state of all channel backups. Each time a
  ///new channel is added, we return the new set of channels, along with a
  ///multi-chan backup containing the backup info for all channels. Each time a
  ///channel is closed, we send a new update, which contains new new chan back
  ///ups, but the updated set of encrypted multi-chan backups with the closed
  ///channel(s) removed.
  ///
  /// - Parameters:
  ///   - request: Request to send to SubscribeChannelBackups.
  ///   - callOptions: Call options.
  ///   - handler: A closure called when each response is received from the server.
  /// - Returns: A `ServerStreamingCall` with futures for the metadata and status.
  internal func subscribeChannelBackups(
    _ request: Lnrpc_ChannelBackupSubscription,
    callOptions: CallOptions? = nil,
    handler: @escaping (Lnrpc_ChanBackupSnapshot) -> Void
  ) -> ServerStreamingCall<Lnrpc_ChannelBackupSubscription, Lnrpc_ChanBackupSnapshot> {
    return self.makeServerStreamingCall(
      path: Lnrpc_LightningClientMetadata.Methods.subscribeChannelBackups.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeSubscribeChannelBackupsInterceptors() ?? [],
      handler: handler
    )
  }

  /// lncli: `bakemacaroon`
  ///BakeMacaroon allows the creation of a new macaroon with custom read and
  ///write permissions. No first-party caveats are added since this can be done
  ///offline.
  ///
  /// - Parameters:
  ///   - request: Request to send to BakeMacaroon.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  internal func bakeMacaroon(
    _ request: Lnrpc_BakeMacaroonRequest,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Lnrpc_BakeMacaroonRequest, Lnrpc_BakeMacaroonResponse> {
    return self.makeUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.bakeMacaroon.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeBakeMacaroonInterceptors() ?? []
    )
  }

  /// lncli: `listmacaroonids`
  ///ListMacaroonIDs returns all root key IDs that are in use.
  ///
  /// - Parameters:
  ///   - request: Request to send to ListMacaroonIDs.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  internal func listMacaroonIDs(
    _ request: Lnrpc_ListMacaroonIDsRequest,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Lnrpc_ListMacaroonIDsRequest, Lnrpc_ListMacaroonIDsResponse> {
    return self.makeUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.listMacaroonIDs.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeListMacaroonIDsInterceptors() ?? []
    )
  }

  /// lncli: `deletemacaroonid`
  ///DeleteMacaroonID deletes the specified macaroon ID and invalidates all
  ///macaroons derived from that ID.
  ///
  /// - Parameters:
  ///   - request: Request to send to DeleteMacaroonID.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  internal func deleteMacaroonID(
    _ request: Lnrpc_DeleteMacaroonIDRequest,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Lnrpc_DeleteMacaroonIDRequest, Lnrpc_DeleteMacaroonIDResponse> {
    return self.makeUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.deleteMacaroonID.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeDeleteMacaroonIDInterceptors() ?? []
    )
  }

  /// lncli: `listpermissions`
  ///ListPermissions lists all RPC method URIs and their required macaroon
  ///permissions to access them.
  ///
  /// - Parameters:
  ///   - request: Request to send to ListPermissions.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  internal func listPermissions(
    _ request: Lnrpc_ListPermissionsRequest,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Lnrpc_ListPermissionsRequest, Lnrpc_ListPermissionsResponse> {
    return self.makeUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.listPermissions.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeListPermissionsInterceptors() ?? []
    )
  }

  ///
  ///CheckMacaroonPermissions checks whether a request follows the constraints
  ///imposed on the macaroon and that the macaroon is authorized to follow the
  ///provided permissions.
  ///
  /// - Parameters:
  ///   - request: Request to send to CheckMacaroonPermissions.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  internal func checkMacaroonPermissions(
    _ request: Lnrpc_CheckMacPermRequest,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Lnrpc_CheckMacPermRequest, Lnrpc_CheckMacPermResponse> {
    return self.makeUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.checkMacaroonPermissions.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeCheckMacaroonPermissionsInterceptors() ?? []
    )
  }

  ///
  ///RegisterRPCMiddleware adds a new gRPC middleware to the interceptor chain. A
  ///gRPC middleware is software component external to lnd that aims to add
  ///additional business logic to lnd by observing/intercepting/validating
  ///incoming gRPC client requests and (if needed) replacing/overwriting outgoing
  ///messages before they're sent to the client. When registering the middleware
  ///must identify itself and indicate what custom macaroon caveats it wants to
  ///be responsible for. Only requests that contain a macaroon with that specific
  ///custom caveat are then sent to the middleware for inspection. The other
  ///option is to register for the read-only mode in which all requests/responses
  ///are forwarded for interception to the middleware but the middleware is not
  ///allowed to modify any responses. As a security measure, _no_ middleware can
  ///modify responses for requests made with _unencumbered_ macaroons!
  ///
  /// Callers should use the `send` method on the returned object to send messages
  /// to the server. The caller should send an `.end` after the final message has been sent.
  ///
  /// - Parameters:
  ///   - callOptions: Call options.
  ///   - handler: A closure called when each response is received from the server.
  /// - Returns: A `ClientStreamingCall` with futures for the metadata and status.
  internal func registerRPCMiddleware(
    callOptions: CallOptions? = nil,
    handler: @escaping (Lnrpc_RPCMiddlewareRequest) -> Void
  ) -> BidirectionalStreamingCall<Lnrpc_RPCMiddlewareResponse, Lnrpc_RPCMiddlewareRequest> {
    return self.makeBidirectionalStreamingCall(
      path: Lnrpc_LightningClientMetadata.Methods.registerRPCMiddleware.path,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeRegisterRPCMiddlewareInterceptors() ?? [],
      handler: handler
    )
  }

  /// lncli: `sendcustom`
  ///SendCustomMessage sends a custom peer message.
  ///
  /// - Parameters:
  ///   - request: Request to send to SendCustomMessage.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  internal func sendCustomMessage(
    _ request: Lnrpc_SendCustomMessageRequest,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Lnrpc_SendCustomMessageRequest, Lnrpc_SendCustomMessageResponse> {
    return self.makeUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.sendCustomMessage.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeSendCustomMessageInterceptors() ?? []
    )
  }

  /// lncli: `subscribecustom`
  ///SubscribeCustomMessages subscribes to a stream of incoming custom peer
  ///messages.
  ///
  ///To include messages with type outside of the custom range (>= 32768) lnd
  ///needs to be compiled with  the `dev` build tag, and the message type to
  ///override should be specified in lnd's experimental protocol configuration.
  ///
  /// - Parameters:
  ///   - request: Request to send to SubscribeCustomMessages.
  ///   - callOptions: Call options.
  ///   - handler: A closure called when each response is received from the server.
  /// - Returns: A `ServerStreamingCall` with futures for the metadata and status.
  internal func subscribeCustomMessages(
    _ request: Lnrpc_SubscribeCustomMessagesRequest,
    callOptions: CallOptions? = nil,
    handler: @escaping (Lnrpc_CustomMessage) -> Void
  ) -> ServerStreamingCall<Lnrpc_SubscribeCustomMessagesRequest, Lnrpc_CustomMessage> {
    return self.makeServerStreamingCall(
      path: Lnrpc_LightningClientMetadata.Methods.subscribeCustomMessages.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeSubscribeCustomMessagesInterceptors() ?? [],
      handler: handler
    )
  }

  /// lncli: `listaliases`
  ///ListAliases returns the set of all aliases that have ever existed with
  ///their confirmed SCID (if it exists) and/or the base SCID (in the case of
  ///zero conf).
  ///
  /// - Parameters:
  ///   - request: Request to send to ListAliases.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  internal func listAliases(
    _ request: Lnrpc_ListAliasesRequest,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Lnrpc_ListAliasesRequest, Lnrpc_ListAliasesResponse> {
    return self.makeUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.listAliases.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeListAliasesInterceptors() ?? []
    )
  }

  ///
  ///LookupHtlcResolution retrieves a final htlc resolution from the database.
  ///If the htlc has no final resolution yet, a NotFound grpc status code is
  ///returned.
  ///
  /// - Parameters:
  ///   - request: Request to send to LookupHtlcResolution.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  internal func lookupHtlcResolution(
    _ request: Lnrpc_LookupHtlcResolutionRequest,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Lnrpc_LookupHtlcResolutionRequest, Lnrpc_LookupHtlcResolutionResponse> {
    return self.makeUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.lookupHtlcResolution.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeLookupHtlcResolutionInterceptors() ?? []
    )
  }
}

@available(*, deprecated)
extension Lnrpc_LightningClient: @unchecked Sendable {}

@available(*, deprecated, renamed: "Lnrpc_LightningNIOClient")
internal final class Lnrpc_LightningClient: Lnrpc_LightningClientProtocol {
  private let lock = Lock()
  private var _defaultCallOptions: CallOptions
  private var _interceptors: Lnrpc_LightningClientInterceptorFactoryProtocol?
  internal let channel: GRPCChannel
  internal var defaultCallOptions: CallOptions {
    get { self.lock.withLock { return self._defaultCallOptions } }
    set { self.lock.withLockVoid { self._defaultCallOptions = newValue } }
  }
  internal var interceptors: Lnrpc_LightningClientInterceptorFactoryProtocol? {
    get { self.lock.withLock { return self._interceptors } }
    set { self.lock.withLockVoid { self._interceptors = newValue } }
  }

  /// Creates a client for the lnrpc.Lightning service.
  ///
  /// - Parameters:
  ///   - channel: `GRPCChannel` to the service host.
  ///   - defaultCallOptions: Options to use for each service call if the user doesn't provide them.
  ///   - interceptors: A factory providing interceptors for each RPC.
  internal init(
    channel: GRPCChannel,
    defaultCallOptions: CallOptions = CallOptions(),
    interceptors: Lnrpc_LightningClientInterceptorFactoryProtocol? = nil
  ) {
    self.channel = channel
    self._defaultCallOptions = defaultCallOptions
    self._interceptors = interceptors
  }
}

internal struct Lnrpc_LightningNIOClient: Lnrpc_LightningClientProtocol {
  internal var channel: GRPCChannel
  internal var defaultCallOptions: CallOptions
  internal var interceptors: Lnrpc_LightningClientInterceptorFactoryProtocol?

  /// Creates a client for the lnrpc.Lightning service.
  ///
  /// - Parameters:
  ///   - channel: `GRPCChannel` to the service host.
  ///   - defaultCallOptions: Options to use for each service call if the user doesn't provide them.
  ///   - interceptors: A factory providing interceptors for each RPC.
  internal init(
    channel: GRPCChannel,
    defaultCallOptions: CallOptions = CallOptions(),
    interceptors: Lnrpc_LightningClientInterceptorFactoryProtocol? = nil
  ) {
    self.channel = channel
    self.defaultCallOptions = defaultCallOptions
    self.interceptors = interceptors
  }
}

/// Lightning is the main RPC server of the daemon.
@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
internal protocol Lnrpc_LightningAsyncClientProtocol: GRPCClient {
  static var serviceDescriptor: GRPCServiceDescriptor { get }
  var interceptors: Lnrpc_LightningClientInterceptorFactoryProtocol? { get }

  func makeWalletBalanceCall(
    _ request: Lnrpc_WalletBalanceRequest,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Lnrpc_WalletBalanceRequest, Lnrpc_WalletBalanceResponse>

  func makeChannelBalanceCall(
    _ request: Lnrpc_ChannelBalanceRequest,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Lnrpc_ChannelBalanceRequest, Lnrpc_ChannelBalanceResponse>

  func makeGetTransactionsCall(
    _ request: Lnrpc_GetTransactionsRequest,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Lnrpc_GetTransactionsRequest, Lnrpc_TransactionDetails>

  func makeEstimateFeeCall(
    _ request: Lnrpc_EstimateFeeRequest,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Lnrpc_EstimateFeeRequest, Lnrpc_EstimateFeeResponse>

  func makeSendCoinsCall(
    _ request: Lnrpc_SendCoinsRequest,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Lnrpc_SendCoinsRequest, Lnrpc_SendCoinsResponse>

  func makeListUnspentCall(
    _ request: Lnrpc_ListUnspentRequest,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Lnrpc_ListUnspentRequest, Lnrpc_ListUnspentResponse>

  func makeSubscribeTransactionsCall(
    _ request: Lnrpc_GetTransactionsRequest,
    callOptions: CallOptions?
  ) -> GRPCAsyncServerStreamingCall<Lnrpc_GetTransactionsRequest, Lnrpc_Transaction>

  func makeSendManyCall(
    _ request: Lnrpc_SendManyRequest,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Lnrpc_SendManyRequest, Lnrpc_SendManyResponse>

  func makeNewAddressCall(
    _ request: Lnrpc_NewAddressRequest,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Lnrpc_NewAddressRequest, Lnrpc_NewAddressResponse>

  func makeSignMessageCall(
    _ request: Lnrpc_SignMessageRequest,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Lnrpc_SignMessageRequest, Lnrpc_SignMessageResponse>

  func makeVerifyMessageCall(
    _ request: Lnrpc_VerifyMessageRequest,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Lnrpc_VerifyMessageRequest, Lnrpc_VerifyMessageResponse>

  func makeConnectPeerCall(
    _ request: Lnrpc_ConnectPeerRequest,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Lnrpc_ConnectPeerRequest, Lnrpc_ConnectPeerResponse>

  func makeDisconnectPeerCall(
    _ request: Lnrpc_DisconnectPeerRequest,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Lnrpc_DisconnectPeerRequest, Lnrpc_DisconnectPeerResponse>

  func makeListPeersCall(
    _ request: Lnrpc_ListPeersRequest,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Lnrpc_ListPeersRequest, Lnrpc_ListPeersResponse>

  func makeSubscribePeerEventsCall(
    _ request: Lnrpc_PeerEventSubscription,
    callOptions: CallOptions?
  ) -> GRPCAsyncServerStreamingCall<Lnrpc_PeerEventSubscription, Lnrpc_PeerEvent>

  func makeGetInfoCall(
    _ request: Lnrpc_GetInfoRequest,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Lnrpc_GetInfoRequest, Lnrpc_GetInfoResponse>

  func makeGetRecoveryInfoCall(
    _ request: Lnrpc_GetRecoveryInfoRequest,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Lnrpc_GetRecoveryInfoRequest, Lnrpc_GetRecoveryInfoResponse>

  func makePendingChannelsCall(
    _ request: Lnrpc_PendingChannelsRequest,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Lnrpc_PendingChannelsRequest, Lnrpc_PendingChannelsResponse>

  func makeListChannelsCall(
    _ request: Lnrpc_ListChannelsRequest,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Lnrpc_ListChannelsRequest, Lnrpc_ListChannelsResponse>

  func makeSubscribeChannelEventsCall(
    _ request: Lnrpc_ChannelEventSubscription,
    callOptions: CallOptions?
  ) -> GRPCAsyncServerStreamingCall<Lnrpc_ChannelEventSubscription, Lnrpc_ChannelEventUpdate>

  func makeClosedChannelsCall(
    _ request: Lnrpc_ClosedChannelsRequest,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Lnrpc_ClosedChannelsRequest, Lnrpc_ClosedChannelsResponse>

  func makeOpenChannelSyncCall(
    _ request: Lnrpc_OpenChannelRequest,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Lnrpc_OpenChannelRequest, Lnrpc_ChannelPoint>

  func makeOpenChannelCall(
    _ request: Lnrpc_OpenChannelRequest,
    callOptions: CallOptions?
  ) -> GRPCAsyncServerStreamingCall<Lnrpc_OpenChannelRequest, Lnrpc_OpenStatusUpdate>

  func makeBatchOpenChannelCall(
    _ request: Lnrpc_BatchOpenChannelRequest,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Lnrpc_BatchOpenChannelRequest, Lnrpc_BatchOpenChannelResponse>

  func makeFundingStateStepCall(
    _ request: Lnrpc_FundingTransitionMsg,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Lnrpc_FundingTransitionMsg, Lnrpc_FundingStateStepResp>

  func makeChannelAcceptorCall(
    callOptions: CallOptions?
  ) -> GRPCAsyncBidirectionalStreamingCall<Lnrpc_ChannelAcceptResponse, Lnrpc_ChannelAcceptRequest>

  func makeCloseChannelCall(
    _ request: Lnrpc_CloseChannelRequest,
    callOptions: CallOptions?
  ) -> GRPCAsyncServerStreamingCall<Lnrpc_CloseChannelRequest, Lnrpc_CloseStatusUpdate>

  func makeAbandonChannelCall(
    _ request: Lnrpc_AbandonChannelRequest,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Lnrpc_AbandonChannelRequest, Lnrpc_AbandonChannelResponse>

  func makeSendPaymentCall(
    callOptions: CallOptions?
  ) -> GRPCAsyncBidirectionalStreamingCall<Lnrpc_SendRequest, Lnrpc_SendResponse>

  func makeSendPaymentSyncCall(
    _ request: Lnrpc_SendRequest,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Lnrpc_SendRequest, Lnrpc_SendResponse>

  func makeSendToRouteCall(
    callOptions: CallOptions?
  ) -> GRPCAsyncBidirectionalStreamingCall<Lnrpc_SendToRouteRequest, Lnrpc_SendResponse>

  func makeSendToRouteSyncCall(
    _ request: Lnrpc_SendToRouteRequest,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Lnrpc_SendToRouteRequest, Lnrpc_SendResponse>

  func makeAddInvoiceCall(
    _ request: Lnrpc_Invoice,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Lnrpc_Invoice, Lnrpc_AddInvoiceResponse>

  func makeListInvoicesCall(
    _ request: Lnrpc_ListInvoiceRequest,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Lnrpc_ListInvoiceRequest, Lnrpc_ListInvoiceResponse>

  func makeLookupInvoiceCall(
    _ request: Lnrpc_PaymentHash,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Lnrpc_PaymentHash, Lnrpc_Invoice>

  func makeSubscribeInvoicesCall(
    _ request: Lnrpc_InvoiceSubscription,
    callOptions: CallOptions?
  ) -> GRPCAsyncServerStreamingCall<Lnrpc_InvoiceSubscription, Lnrpc_Invoice>

  func makeDecodePayReqCall(
    _ request: Lnrpc_PayReqString,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Lnrpc_PayReqString, Lnrpc_PayReq>

  func makeListPaymentsCall(
    _ request: Lnrpc_ListPaymentsRequest,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Lnrpc_ListPaymentsRequest, Lnrpc_ListPaymentsResponse>

  func makeDeletePaymentCall(
    _ request: Lnrpc_DeletePaymentRequest,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Lnrpc_DeletePaymentRequest, Lnrpc_DeletePaymentResponse>

  func makeDeleteAllPaymentsCall(
    _ request: Lnrpc_DeleteAllPaymentsRequest,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Lnrpc_DeleteAllPaymentsRequest, Lnrpc_DeleteAllPaymentsResponse>

  func makeDescribeGraphCall(
    _ request: Lnrpc_ChannelGraphRequest,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Lnrpc_ChannelGraphRequest, Lnrpc_ChannelGraph>

  func makeGetNodeMetricsCall(
    _ request: Lnrpc_NodeMetricsRequest,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Lnrpc_NodeMetricsRequest, Lnrpc_NodeMetricsResponse>

  func makeGetChanInfoCall(
    _ request: Lnrpc_ChanInfoRequest,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Lnrpc_ChanInfoRequest, Lnrpc_ChannelEdge>

  func makeGetNodeInfoCall(
    _ request: Lnrpc_NodeInfoRequest,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Lnrpc_NodeInfoRequest, Lnrpc_NodeInfo>

  func makeQueryRoutesCall(
    _ request: Lnrpc_QueryRoutesRequest,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Lnrpc_QueryRoutesRequest, Lnrpc_QueryRoutesResponse>

  func makeGetNetworkInfoCall(
    _ request: Lnrpc_NetworkInfoRequest,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Lnrpc_NetworkInfoRequest, Lnrpc_NetworkInfo>

  func makeStopDaemonCall(
    _ request: Lnrpc_StopRequest,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Lnrpc_StopRequest, Lnrpc_StopResponse>

  func makeSubscribeChannelGraphCall(
    _ request: Lnrpc_GraphTopologySubscription,
    callOptions: CallOptions?
  ) -> GRPCAsyncServerStreamingCall<Lnrpc_GraphTopologySubscription, Lnrpc_GraphTopologyUpdate>

  func makeDebugLevelCall(
    _ request: Lnrpc_DebugLevelRequest,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Lnrpc_DebugLevelRequest, Lnrpc_DebugLevelResponse>

  func makeFeeReportCall(
    _ request: Lnrpc_FeeReportRequest,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Lnrpc_FeeReportRequest, Lnrpc_FeeReportResponse>

  func makeUpdateChannelPolicyCall(
    _ request: Lnrpc_PolicyUpdateRequest,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Lnrpc_PolicyUpdateRequest, Lnrpc_PolicyUpdateResponse>

  func makeForwardingHistoryCall(
    _ request: Lnrpc_ForwardingHistoryRequest,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Lnrpc_ForwardingHistoryRequest, Lnrpc_ForwardingHistoryResponse>

  func makeExportChannelBackupCall(
    _ request: Lnrpc_ExportChannelBackupRequest,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Lnrpc_ExportChannelBackupRequest, Lnrpc_ChannelBackup>

  func makeExportAllChannelBackupsCall(
    _ request: Lnrpc_ChanBackupExportRequest,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Lnrpc_ChanBackupExportRequest, Lnrpc_ChanBackupSnapshot>

  func makeVerifyChanBackupCall(
    _ request: Lnrpc_ChanBackupSnapshot,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Lnrpc_ChanBackupSnapshot, Lnrpc_VerifyChanBackupResponse>

  func makeRestoreChannelBackupsCall(
    _ request: Lnrpc_RestoreChanBackupRequest,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Lnrpc_RestoreChanBackupRequest, Lnrpc_RestoreBackupResponse>

  func makeSubscribeChannelBackupsCall(
    _ request: Lnrpc_ChannelBackupSubscription,
    callOptions: CallOptions?
  ) -> GRPCAsyncServerStreamingCall<Lnrpc_ChannelBackupSubscription, Lnrpc_ChanBackupSnapshot>

  func makeBakeMacaroonCall(
    _ request: Lnrpc_BakeMacaroonRequest,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Lnrpc_BakeMacaroonRequest, Lnrpc_BakeMacaroonResponse>

  func makeListMacaroonIdsCall(
    _ request: Lnrpc_ListMacaroonIDsRequest,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Lnrpc_ListMacaroonIDsRequest, Lnrpc_ListMacaroonIDsResponse>

  func makeDeleteMacaroonIDCall(
    _ request: Lnrpc_DeleteMacaroonIDRequest,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Lnrpc_DeleteMacaroonIDRequest, Lnrpc_DeleteMacaroonIDResponse>

  func makeListPermissionsCall(
    _ request: Lnrpc_ListPermissionsRequest,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Lnrpc_ListPermissionsRequest, Lnrpc_ListPermissionsResponse>

  func makeCheckMacaroonPermissionsCall(
    _ request: Lnrpc_CheckMacPermRequest,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Lnrpc_CheckMacPermRequest, Lnrpc_CheckMacPermResponse>

  func makeRegisterRpcmiddlewareCall(
    callOptions: CallOptions?
  ) -> GRPCAsyncBidirectionalStreamingCall<Lnrpc_RPCMiddlewareResponse, Lnrpc_RPCMiddlewareRequest>

  func makeSendCustomMessageCall(
    _ request: Lnrpc_SendCustomMessageRequest,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Lnrpc_SendCustomMessageRequest, Lnrpc_SendCustomMessageResponse>

  func makeSubscribeCustomMessagesCall(
    _ request: Lnrpc_SubscribeCustomMessagesRequest,
    callOptions: CallOptions?
  ) -> GRPCAsyncServerStreamingCall<Lnrpc_SubscribeCustomMessagesRequest, Lnrpc_CustomMessage>

  func makeListAliasesCall(
    _ request: Lnrpc_ListAliasesRequest,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Lnrpc_ListAliasesRequest, Lnrpc_ListAliasesResponse>

  func makeLookupHtlcResolutionCall(
    _ request: Lnrpc_LookupHtlcResolutionRequest,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<Lnrpc_LookupHtlcResolutionRequest, Lnrpc_LookupHtlcResolutionResponse>
}

@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
extension Lnrpc_LightningAsyncClientProtocol {
  internal static var serviceDescriptor: GRPCServiceDescriptor {
    return Lnrpc_LightningClientMetadata.serviceDescriptor
  }

  internal var interceptors: Lnrpc_LightningClientInterceptorFactoryProtocol? {
    return nil
  }

  internal func makeWalletBalanceCall(
    _ request: Lnrpc_WalletBalanceRequest,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Lnrpc_WalletBalanceRequest, Lnrpc_WalletBalanceResponse> {
    return self.makeAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.walletBalance.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeWalletBalanceInterceptors() ?? []
    )
  }

  internal func makeChannelBalanceCall(
    _ request: Lnrpc_ChannelBalanceRequest,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Lnrpc_ChannelBalanceRequest, Lnrpc_ChannelBalanceResponse> {
    return self.makeAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.channelBalance.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeChannelBalanceInterceptors() ?? []
    )
  }

  internal func makeGetTransactionsCall(
    _ request: Lnrpc_GetTransactionsRequest,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Lnrpc_GetTransactionsRequest, Lnrpc_TransactionDetails> {
    return self.makeAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.getTransactions.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeGetTransactionsInterceptors() ?? []
    )
  }

  internal func makeEstimateFeeCall(
    _ request: Lnrpc_EstimateFeeRequest,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Lnrpc_EstimateFeeRequest, Lnrpc_EstimateFeeResponse> {
    return self.makeAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.estimateFee.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeEstimateFeeInterceptors() ?? []
    )
  }

  internal func makeSendCoinsCall(
    _ request: Lnrpc_SendCoinsRequest,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Lnrpc_SendCoinsRequest, Lnrpc_SendCoinsResponse> {
    return self.makeAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.sendCoins.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeSendCoinsInterceptors() ?? []
    )
  }

  internal func makeListUnspentCall(
    _ request: Lnrpc_ListUnspentRequest,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Lnrpc_ListUnspentRequest, Lnrpc_ListUnspentResponse> {
    return self.makeAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.listUnspent.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeListUnspentInterceptors() ?? []
    )
  }

  internal func makeSubscribeTransactionsCall(
    _ request: Lnrpc_GetTransactionsRequest,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncServerStreamingCall<Lnrpc_GetTransactionsRequest, Lnrpc_Transaction> {
    return self.makeAsyncServerStreamingCall(
      path: Lnrpc_LightningClientMetadata.Methods.subscribeTransactions.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeSubscribeTransactionsInterceptors() ?? []
    )
  }

  internal func makeSendManyCall(
    _ request: Lnrpc_SendManyRequest,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Lnrpc_SendManyRequest, Lnrpc_SendManyResponse> {
    return self.makeAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.sendMany.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeSendManyInterceptors() ?? []
    )
  }

  internal func makeNewAddressCall(
    _ request: Lnrpc_NewAddressRequest,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Lnrpc_NewAddressRequest, Lnrpc_NewAddressResponse> {
    return self.makeAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.newAddress.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeNewAddressInterceptors() ?? []
    )
  }

  internal func makeSignMessageCall(
    _ request: Lnrpc_SignMessageRequest,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Lnrpc_SignMessageRequest, Lnrpc_SignMessageResponse> {
    return self.makeAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.signMessage.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeSignMessageInterceptors() ?? []
    )
  }

  internal func makeVerifyMessageCall(
    _ request: Lnrpc_VerifyMessageRequest,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Lnrpc_VerifyMessageRequest, Lnrpc_VerifyMessageResponse> {
    return self.makeAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.verifyMessage.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeVerifyMessageInterceptors() ?? []
    )
  }

  internal func makeConnectPeerCall(
    _ request: Lnrpc_ConnectPeerRequest,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Lnrpc_ConnectPeerRequest, Lnrpc_ConnectPeerResponse> {
    return self.makeAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.connectPeer.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeConnectPeerInterceptors() ?? []
    )
  }

  internal func makeDisconnectPeerCall(
    _ request: Lnrpc_DisconnectPeerRequest,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Lnrpc_DisconnectPeerRequest, Lnrpc_DisconnectPeerResponse> {
    return self.makeAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.disconnectPeer.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeDisconnectPeerInterceptors() ?? []
    )
  }

  internal func makeListPeersCall(
    _ request: Lnrpc_ListPeersRequest,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Lnrpc_ListPeersRequest, Lnrpc_ListPeersResponse> {
    return self.makeAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.listPeers.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeListPeersInterceptors() ?? []
    )
  }

  internal func makeSubscribePeerEventsCall(
    _ request: Lnrpc_PeerEventSubscription,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncServerStreamingCall<Lnrpc_PeerEventSubscription, Lnrpc_PeerEvent> {
    return self.makeAsyncServerStreamingCall(
      path: Lnrpc_LightningClientMetadata.Methods.subscribePeerEvents.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeSubscribePeerEventsInterceptors() ?? []
    )
  }

  internal func makeGetInfoCall(
    _ request: Lnrpc_GetInfoRequest,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Lnrpc_GetInfoRequest, Lnrpc_GetInfoResponse> {
    return self.makeAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.getInfo.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeGetInfoInterceptors() ?? []
    )
  }

  internal func makeGetRecoveryInfoCall(
    _ request: Lnrpc_GetRecoveryInfoRequest,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Lnrpc_GetRecoveryInfoRequest, Lnrpc_GetRecoveryInfoResponse> {
    return self.makeAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.getRecoveryInfo.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeGetRecoveryInfoInterceptors() ?? []
    )
  }

  internal func makePendingChannelsCall(
    _ request: Lnrpc_PendingChannelsRequest,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Lnrpc_PendingChannelsRequest, Lnrpc_PendingChannelsResponse> {
    return self.makeAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.pendingChannels.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makePendingChannelsInterceptors() ?? []
    )
  }

  internal func makeListChannelsCall(
    _ request: Lnrpc_ListChannelsRequest,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Lnrpc_ListChannelsRequest, Lnrpc_ListChannelsResponse> {
    return self.makeAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.listChannels.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeListChannelsInterceptors() ?? []
    )
  }

  internal func makeSubscribeChannelEventsCall(
    _ request: Lnrpc_ChannelEventSubscription,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncServerStreamingCall<Lnrpc_ChannelEventSubscription, Lnrpc_ChannelEventUpdate> {
    return self.makeAsyncServerStreamingCall(
      path: Lnrpc_LightningClientMetadata.Methods.subscribeChannelEvents.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeSubscribeChannelEventsInterceptors() ?? []
    )
  }

  internal func makeClosedChannelsCall(
    _ request: Lnrpc_ClosedChannelsRequest,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Lnrpc_ClosedChannelsRequest, Lnrpc_ClosedChannelsResponse> {
    return self.makeAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.closedChannels.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeClosedChannelsInterceptors() ?? []
    )
  }

  internal func makeOpenChannelSyncCall(
    _ request: Lnrpc_OpenChannelRequest,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Lnrpc_OpenChannelRequest, Lnrpc_ChannelPoint> {
    return self.makeAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.openChannelSync.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeOpenChannelSyncInterceptors() ?? []
    )
  }

  internal func makeOpenChannelCall(
    _ request: Lnrpc_OpenChannelRequest,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncServerStreamingCall<Lnrpc_OpenChannelRequest, Lnrpc_OpenStatusUpdate> {
    return self.makeAsyncServerStreamingCall(
      path: Lnrpc_LightningClientMetadata.Methods.openChannel.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeOpenChannelInterceptors() ?? []
    )
  }

  internal func makeBatchOpenChannelCall(
    _ request: Lnrpc_BatchOpenChannelRequest,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Lnrpc_BatchOpenChannelRequest, Lnrpc_BatchOpenChannelResponse> {
    return self.makeAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.batchOpenChannel.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeBatchOpenChannelInterceptors() ?? []
    )
  }

  internal func makeFundingStateStepCall(
    _ request: Lnrpc_FundingTransitionMsg,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Lnrpc_FundingTransitionMsg, Lnrpc_FundingStateStepResp> {
    return self.makeAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.fundingStateStep.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeFundingStateStepInterceptors() ?? []
    )
  }

  internal func makeChannelAcceptorCall(
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncBidirectionalStreamingCall<Lnrpc_ChannelAcceptResponse, Lnrpc_ChannelAcceptRequest> {
    return self.makeAsyncBidirectionalStreamingCall(
      path: Lnrpc_LightningClientMetadata.Methods.channelAcceptor.path,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeChannelAcceptorInterceptors() ?? []
    )
  }

  internal func makeCloseChannelCall(
    _ request: Lnrpc_CloseChannelRequest,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncServerStreamingCall<Lnrpc_CloseChannelRequest, Lnrpc_CloseStatusUpdate> {
    return self.makeAsyncServerStreamingCall(
      path: Lnrpc_LightningClientMetadata.Methods.closeChannel.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeCloseChannelInterceptors() ?? []
    )
  }

  internal func makeAbandonChannelCall(
    _ request: Lnrpc_AbandonChannelRequest,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Lnrpc_AbandonChannelRequest, Lnrpc_AbandonChannelResponse> {
    return self.makeAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.abandonChannel.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeAbandonChannelInterceptors() ?? []
    )
  }

  internal func makeSendPaymentCall(
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncBidirectionalStreamingCall<Lnrpc_SendRequest, Lnrpc_SendResponse> {
    return self.makeAsyncBidirectionalStreamingCall(
      path: Lnrpc_LightningClientMetadata.Methods.sendPayment.path,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeSendPaymentInterceptors() ?? []
    )
  }

  internal func makeSendPaymentSyncCall(
    _ request: Lnrpc_SendRequest,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Lnrpc_SendRequest, Lnrpc_SendResponse> {
    return self.makeAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.sendPaymentSync.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeSendPaymentSyncInterceptors() ?? []
    )
  }

  internal func makeSendToRouteCall(
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncBidirectionalStreamingCall<Lnrpc_SendToRouteRequest, Lnrpc_SendResponse> {
    return self.makeAsyncBidirectionalStreamingCall(
      path: Lnrpc_LightningClientMetadata.Methods.sendToRoute.path,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeSendToRouteInterceptors() ?? []
    )
  }

  internal func makeSendToRouteSyncCall(
    _ request: Lnrpc_SendToRouteRequest,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Lnrpc_SendToRouteRequest, Lnrpc_SendResponse> {
    return self.makeAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.sendToRouteSync.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeSendToRouteSyncInterceptors() ?? []
    )
  }

  internal func makeAddInvoiceCall(
    _ request: Lnrpc_Invoice,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Lnrpc_Invoice, Lnrpc_AddInvoiceResponse> {
    return self.makeAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.addInvoice.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeAddInvoiceInterceptors() ?? []
    )
  }

  internal func makeListInvoicesCall(
    _ request: Lnrpc_ListInvoiceRequest,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Lnrpc_ListInvoiceRequest, Lnrpc_ListInvoiceResponse> {
    return self.makeAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.listInvoices.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeListInvoicesInterceptors() ?? []
    )
  }

  internal func makeLookupInvoiceCall(
    _ request: Lnrpc_PaymentHash,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Lnrpc_PaymentHash, Lnrpc_Invoice> {
    return self.makeAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.lookupInvoice.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeLookupInvoiceInterceptors() ?? []
    )
  }

  internal func makeSubscribeInvoicesCall(
    _ request: Lnrpc_InvoiceSubscription,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncServerStreamingCall<Lnrpc_InvoiceSubscription, Lnrpc_Invoice> {
    return self.makeAsyncServerStreamingCall(
      path: Lnrpc_LightningClientMetadata.Methods.subscribeInvoices.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeSubscribeInvoicesInterceptors() ?? []
    )
  }

  internal func makeDecodePayReqCall(
    _ request: Lnrpc_PayReqString,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Lnrpc_PayReqString, Lnrpc_PayReq> {
    return self.makeAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.decodePayReq.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeDecodePayReqInterceptors() ?? []
    )
  }

  internal func makeListPaymentsCall(
    _ request: Lnrpc_ListPaymentsRequest,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Lnrpc_ListPaymentsRequest, Lnrpc_ListPaymentsResponse> {
    return self.makeAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.listPayments.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeListPaymentsInterceptors() ?? []
    )
  }

  internal func makeDeletePaymentCall(
    _ request: Lnrpc_DeletePaymentRequest,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Lnrpc_DeletePaymentRequest, Lnrpc_DeletePaymentResponse> {
    return self.makeAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.deletePayment.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeDeletePaymentInterceptors() ?? []
    )
  }

  internal func makeDeleteAllPaymentsCall(
    _ request: Lnrpc_DeleteAllPaymentsRequest,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Lnrpc_DeleteAllPaymentsRequest, Lnrpc_DeleteAllPaymentsResponse> {
    return self.makeAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.deleteAllPayments.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeDeleteAllPaymentsInterceptors() ?? []
    )
  }

  internal func makeDescribeGraphCall(
    _ request: Lnrpc_ChannelGraphRequest,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Lnrpc_ChannelGraphRequest, Lnrpc_ChannelGraph> {
    return self.makeAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.describeGraph.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeDescribeGraphInterceptors() ?? []
    )
  }

  internal func makeGetNodeMetricsCall(
    _ request: Lnrpc_NodeMetricsRequest,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Lnrpc_NodeMetricsRequest, Lnrpc_NodeMetricsResponse> {
    return self.makeAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.getNodeMetrics.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeGetNodeMetricsInterceptors() ?? []
    )
  }

  internal func makeGetChanInfoCall(
    _ request: Lnrpc_ChanInfoRequest,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Lnrpc_ChanInfoRequest, Lnrpc_ChannelEdge> {
    return self.makeAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.getChanInfo.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeGetChanInfoInterceptors() ?? []
    )
  }

  internal func makeGetNodeInfoCall(
    _ request: Lnrpc_NodeInfoRequest,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Lnrpc_NodeInfoRequest, Lnrpc_NodeInfo> {
    return self.makeAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.getNodeInfo.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeGetNodeInfoInterceptors() ?? []
    )
  }

  internal func makeQueryRoutesCall(
    _ request: Lnrpc_QueryRoutesRequest,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Lnrpc_QueryRoutesRequest, Lnrpc_QueryRoutesResponse> {
    return self.makeAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.queryRoutes.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeQueryRoutesInterceptors() ?? []
    )
  }

  internal func makeGetNetworkInfoCall(
    _ request: Lnrpc_NetworkInfoRequest,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Lnrpc_NetworkInfoRequest, Lnrpc_NetworkInfo> {
    return self.makeAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.getNetworkInfo.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeGetNetworkInfoInterceptors() ?? []
    )
  }

  internal func makeStopDaemonCall(
    _ request: Lnrpc_StopRequest,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Lnrpc_StopRequest, Lnrpc_StopResponse> {
    return self.makeAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.stopDaemon.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeStopDaemonInterceptors() ?? []
    )
  }

  internal func makeSubscribeChannelGraphCall(
    _ request: Lnrpc_GraphTopologySubscription,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncServerStreamingCall<Lnrpc_GraphTopologySubscription, Lnrpc_GraphTopologyUpdate> {
    return self.makeAsyncServerStreamingCall(
      path: Lnrpc_LightningClientMetadata.Methods.subscribeChannelGraph.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeSubscribeChannelGraphInterceptors() ?? []
    )
  }

  internal func makeDebugLevelCall(
    _ request: Lnrpc_DebugLevelRequest,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Lnrpc_DebugLevelRequest, Lnrpc_DebugLevelResponse> {
    return self.makeAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.debugLevel.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeDebugLevelInterceptors() ?? []
    )
  }

  internal func makeFeeReportCall(
    _ request: Lnrpc_FeeReportRequest,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Lnrpc_FeeReportRequest, Lnrpc_FeeReportResponse> {
    return self.makeAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.feeReport.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeFeeReportInterceptors() ?? []
    )
  }

  internal func makeUpdateChannelPolicyCall(
    _ request: Lnrpc_PolicyUpdateRequest,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Lnrpc_PolicyUpdateRequest, Lnrpc_PolicyUpdateResponse> {
    return self.makeAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.updateChannelPolicy.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeUpdateChannelPolicyInterceptors() ?? []
    )
  }

  internal func makeForwardingHistoryCall(
    _ request: Lnrpc_ForwardingHistoryRequest,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Lnrpc_ForwardingHistoryRequest, Lnrpc_ForwardingHistoryResponse> {
    return self.makeAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.forwardingHistory.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeForwardingHistoryInterceptors() ?? []
    )
  }

  internal func makeExportChannelBackupCall(
    _ request: Lnrpc_ExportChannelBackupRequest,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Lnrpc_ExportChannelBackupRequest, Lnrpc_ChannelBackup> {
    return self.makeAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.exportChannelBackup.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeExportChannelBackupInterceptors() ?? []
    )
  }

  internal func makeExportAllChannelBackupsCall(
    _ request: Lnrpc_ChanBackupExportRequest,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Lnrpc_ChanBackupExportRequest, Lnrpc_ChanBackupSnapshot> {
    return self.makeAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.exportAllChannelBackups.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeExportAllChannelBackupsInterceptors() ?? []
    )
  }

  internal func makeVerifyChanBackupCall(
    _ request: Lnrpc_ChanBackupSnapshot,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Lnrpc_ChanBackupSnapshot, Lnrpc_VerifyChanBackupResponse> {
    return self.makeAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.verifyChanBackup.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeVerifyChanBackupInterceptors() ?? []
    )
  }

  internal func makeRestoreChannelBackupsCall(
    _ request: Lnrpc_RestoreChanBackupRequest,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Lnrpc_RestoreChanBackupRequest, Lnrpc_RestoreBackupResponse> {
    return self.makeAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.restoreChannelBackups.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeRestoreChannelBackupsInterceptors() ?? []
    )
  }

  internal func makeSubscribeChannelBackupsCall(
    _ request: Lnrpc_ChannelBackupSubscription,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncServerStreamingCall<Lnrpc_ChannelBackupSubscription, Lnrpc_ChanBackupSnapshot> {
    return self.makeAsyncServerStreamingCall(
      path: Lnrpc_LightningClientMetadata.Methods.subscribeChannelBackups.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeSubscribeChannelBackupsInterceptors() ?? []
    )
  }

  internal func makeBakeMacaroonCall(
    _ request: Lnrpc_BakeMacaroonRequest,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Lnrpc_BakeMacaroonRequest, Lnrpc_BakeMacaroonResponse> {
    return self.makeAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.bakeMacaroon.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeBakeMacaroonInterceptors() ?? []
    )
  }

  internal func makeListMacaroonIdsCall(
    _ request: Lnrpc_ListMacaroonIDsRequest,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Lnrpc_ListMacaroonIDsRequest, Lnrpc_ListMacaroonIDsResponse> {
    return self.makeAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.listMacaroonIDs.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeListMacaroonIDsInterceptors() ?? []
    )
  }

  internal func makeDeleteMacaroonIDCall(
    _ request: Lnrpc_DeleteMacaroonIDRequest,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Lnrpc_DeleteMacaroonIDRequest, Lnrpc_DeleteMacaroonIDResponse> {
    return self.makeAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.deleteMacaroonID.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeDeleteMacaroonIDInterceptors() ?? []
    )
  }

  internal func makeListPermissionsCall(
    _ request: Lnrpc_ListPermissionsRequest,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Lnrpc_ListPermissionsRequest, Lnrpc_ListPermissionsResponse> {
    return self.makeAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.listPermissions.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeListPermissionsInterceptors() ?? []
    )
  }

  internal func makeCheckMacaroonPermissionsCall(
    _ request: Lnrpc_CheckMacPermRequest,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Lnrpc_CheckMacPermRequest, Lnrpc_CheckMacPermResponse> {
    return self.makeAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.checkMacaroonPermissions.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeCheckMacaroonPermissionsInterceptors() ?? []
    )
  }

  internal func makeRegisterRpcmiddlewareCall(
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncBidirectionalStreamingCall<Lnrpc_RPCMiddlewareResponse, Lnrpc_RPCMiddlewareRequest> {
    return self.makeAsyncBidirectionalStreamingCall(
      path: Lnrpc_LightningClientMetadata.Methods.registerRPCMiddleware.path,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeRegisterRPCMiddlewareInterceptors() ?? []
    )
  }

  internal func makeSendCustomMessageCall(
    _ request: Lnrpc_SendCustomMessageRequest,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Lnrpc_SendCustomMessageRequest, Lnrpc_SendCustomMessageResponse> {
    return self.makeAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.sendCustomMessage.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeSendCustomMessageInterceptors() ?? []
    )
  }

  internal func makeSubscribeCustomMessagesCall(
    _ request: Lnrpc_SubscribeCustomMessagesRequest,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncServerStreamingCall<Lnrpc_SubscribeCustomMessagesRequest, Lnrpc_CustomMessage> {
    return self.makeAsyncServerStreamingCall(
      path: Lnrpc_LightningClientMetadata.Methods.subscribeCustomMessages.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeSubscribeCustomMessagesInterceptors() ?? []
    )
  }

  internal func makeListAliasesCall(
    _ request: Lnrpc_ListAliasesRequest,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Lnrpc_ListAliasesRequest, Lnrpc_ListAliasesResponse> {
    return self.makeAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.listAliases.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeListAliasesInterceptors() ?? []
    )
  }

  internal func makeLookupHtlcResolutionCall(
    _ request: Lnrpc_LookupHtlcResolutionRequest,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<Lnrpc_LookupHtlcResolutionRequest, Lnrpc_LookupHtlcResolutionResponse> {
    return self.makeAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.lookupHtlcResolution.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeLookupHtlcResolutionInterceptors() ?? []
    )
  }
}

@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
extension Lnrpc_LightningAsyncClientProtocol {
  internal func walletBalance(
    _ request: Lnrpc_WalletBalanceRequest,
    callOptions: CallOptions? = nil
  ) async throws -> Lnrpc_WalletBalanceResponse {
    return try await self.performAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.walletBalance.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeWalletBalanceInterceptors() ?? []
    )
  }

  internal func channelBalance(
    _ request: Lnrpc_ChannelBalanceRequest,
    callOptions: CallOptions? = nil
  ) async throws -> Lnrpc_ChannelBalanceResponse {
    return try await self.performAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.channelBalance.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeChannelBalanceInterceptors() ?? []
    )
  }

  internal func getTransactions(
    _ request: Lnrpc_GetTransactionsRequest,
    callOptions: CallOptions? = nil
  ) async throws -> Lnrpc_TransactionDetails {
    return try await self.performAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.getTransactions.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeGetTransactionsInterceptors() ?? []
    )
  }

  internal func estimateFee(
    _ request: Lnrpc_EstimateFeeRequest,
    callOptions: CallOptions? = nil
  ) async throws -> Lnrpc_EstimateFeeResponse {
    return try await self.performAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.estimateFee.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeEstimateFeeInterceptors() ?? []
    )
  }

  internal func sendCoins(
    _ request: Lnrpc_SendCoinsRequest,
    callOptions: CallOptions? = nil
  ) async throws -> Lnrpc_SendCoinsResponse {
    return try await self.performAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.sendCoins.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeSendCoinsInterceptors() ?? []
    )
  }

  internal func listUnspent(
    _ request: Lnrpc_ListUnspentRequest,
    callOptions: CallOptions? = nil
  ) async throws -> Lnrpc_ListUnspentResponse {
    return try await self.performAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.listUnspent.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeListUnspentInterceptors() ?? []
    )
  }

  internal func subscribeTransactions(
    _ request: Lnrpc_GetTransactionsRequest,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncResponseStream<Lnrpc_Transaction> {
    return self.performAsyncServerStreamingCall(
      path: Lnrpc_LightningClientMetadata.Methods.subscribeTransactions.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeSubscribeTransactionsInterceptors() ?? []
    )
  }

  internal func sendMany(
    _ request: Lnrpc_SendManyRequest,
    callOptions: CallOptions? = nil
  ) async throws -> Lnrpc_SendManyResponse {
    return try await self.performAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.sendMany.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeSendManyInterceptors() ?? []
    )
  }

  internal func newAddress(
    _ request: Lnrpc_NewAddressRequest,
    callOptions: CallOptions? = nil
  ) async throws -> Lnrpc_NewAddressResponse {
    return try await self.performAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.newAddress.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeNewAddressInterceptors() ?? []
    )
  }

  internal func signMessage(
    _ request: Lnrpc_SignMessageRequest,
    callOptions: CallOptions? = nil
  ) async throws -> Lnrpc_SignMessageResponse {
    return try await self.performAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.signMessage.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeSignMessageInterceptors() ?? []
    )
  }

  internal func verifyMessage(
    _ request: Lnrpc_VerifyMessageRequest,
    callOptions: CallOptions? = nil
  ) async throws -> Lnrpc_VerifyMessageResponse {
    return try await self.performAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.verifyMessage.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeVerifyMessageInterceptors() ?? []
    )
  }

  internal func connectPeer(
    _ request: Lnrpc_ConnectPeerRequest,
    callOptions: CallOptions? = nil
  ) async throws -> Lnrpc_ConnectPeerResponse {
    return try await self.performAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.connectPeer.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeConnectPeerInterceptors() ?? []
    )
  }

  internal func disconnectPeer(
    _ request: Lnrpc_DisconnectPeerRequest,
    callOptions: CallOptions? = nil
  ) async throws -> Lnrpc_DisconnectPeerResponse {
    return try await self.performAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.disconnectPeer.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeDisconnectPeerInterceptors() ?? []
    )
  }

  internal func listPeers(
    _ request: Lnrpc_ListPeersRequest,
    callOptions: CallOptions? = nil
  ) async throws -> Lnrpc_ListPeersResponse {
    return try await self.performAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.listPeers.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeListPeersInterceptors() ?? []
    )
  }

  internal func subscribePeerEvents(
    _ request: Lnrpc_PeerEventSubscription,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncResponseStream<Lnrpc_PeerEvent> {
    return self.performAsyncServerStreamingCall(
      path: Lnrpc_LightningClientMetadata.Methods.subscribePeerEvents.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeSubscribePeerEventsInterceptors() ?? []
    )
  }

  internal func getInfo(
    _ request: Lnrpc_GetInfoRequest,
    callOptions: CallOptions? = nil
  ) async throws -> Lnrpc_GetInfoResponse {
    return try await self.performAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.getInfo.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeGetInfoInterceptors() ?? []
    )
  }

  internal func getRecoveryInfo(
    _ request: Lnrpc_GetRecoveryInfoRequest,
    callOptions: CallOptions? = nil
  ) async throws -> Lnrpc_GetRecoveryInfoResponse {
    return try await self.performAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.getRecoveryInfo.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeGetRecoveryInfoInterceptors() ?? []
    )
  }

  internal func pendingChannels(
    _ request: Lnrpc_PendingChannelsRequest,
    callOptions: CallOptions? = nil
  ) async throws -> Lnrpc_PendingChannelsResponse {
    return try await self.performAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.pendingChannels.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makePendingChannelsInterceptors() ?? []
    )
  }

  internal func listChannels(
    _ request: Lnrpc_ListChannelsRequest,
    callOptions: CallOptions? = nil
  ) async throws -> Lnrpc_ListChannelsResponse {
    return try await self.performAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.listChannels.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeListChannelsInterceptors() ?? []
    )
  }

  internal func subscribeChannelEvents(
    _ request: Lnrpc_ChannelEventSubscription,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncResponseStream<Lnrpc_ChannelEventUpdate> {
    return self.performAsyncServerStreamingCall(
      path: Lnrpc_LightningClientMetadata.Methods.subscribeChannelEvents.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeSubscribeChannelEventsInterceptors() ?? []
    )
  }

  internal func closedChannels(
    _ request: Lnrpc_ClosedChannelsRequest,
    callOptions: CallOptions? = nil
  ) async throws -> Lnrpc_ClosedChannelsResponse {
    return try await self.performAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.closedChannels.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeClosedChannelsInterceptors() ?? []
    )
  }

  internal func openChannelSync(
    _ request: Lnrpc_OpenChannelRequest,
    callOptions: CallOptions? = nil
  ) async throws -> Lnrpc_ChannelPoint {
    return try await self.performAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.openChannelSync.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeOpenChannelSyncInterceptors() ?? []
    )
  }

  internal func openChannel(
    _ request: Lnrpc_OpenChannelRequest,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncResponseStream<Lnrpc_OpenStatusUpdate> {
    return self.performAsyncServerStreamingCall(
      path: Lnrpc_LightningClientMetadata.Methods.openChannel.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeOpenChannelInterceptors() ?? []
    )
  }

  internal func batchOpenChannel(
    _ request: Lnrpc_BatchOpenChannelRequest,
    callOptions: CallOptions? = nil
  ) async throws -> Lnrpc_BatchOpenChannelResponse {
    return try await self.performAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.batchOpenChannel.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeBatchOpenChannelInterceptors() ?? []
    )
  }

  internal func fundingStateStep(
    _ request: Lnrpc_FundingTransitionMsg,
    callOptions: CallOptions? = nil
  ) async throws -> Lnrpc_FundingStateStepResp {
    return try await self.performAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.fundingStateStep.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeFundingStateStepInterceptors() ?? []
    )
  }

  internal func channelAcceptor<RequestStream>(
    _ requests: RequestStream,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncResponseStream<Lnrpc_ChannelAcceptRequest> where RequestStream: Sequence, RequestStream.Element == Lnrpc_ChannelAcceptResponse {
    return self.performAsyncBidirectionalStreamingCall(
      path: Lnrpc_LightningClientMetadata.Methods.channelAcceptor.path,
      requests: requests,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeChannelAcceptorInterceptors() ?? []
    )
  }

  internal func channelAcceptor<RequestStream>(
    _ requests: RequestStream,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncResponseStream<Lnrpc_ChannelAcceptRequest> where RequestStream: AsyncSequence & Sendable, RequestStream.Element == Lnrpc_ChannelAcceptResponse {
    return self.performAsyncBidirectionalStreamingCall(
      path: Lnrpc_LightningClientMetadata.Methods.channelAcceptor.path,
      requests: requests,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeChannelAcceptorInterceptors() ?? []
    )
  }

  internal func closeChannel(
    _ request: Lnrpc_CloseChannelRequest,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncResponseStream<Lnrpc_CloseStatusUpdate> {
    return self.performAsyncServerStreamingCall(
      path: Lnrpc_LightningClientMetadata.Methods.closeChannel.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeCloseChannelInterceptors() ?? []
    )
  }

  internal func abandonChannel(
    _ request: Lnrpc_AbandonChannelRequest,
    callOptions: CallOptions? = nil
  ) async throws -> Lnrpc_AbandonChannelResponse {
    return try await self.performAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.abandonChannel.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeAbandonChannelInterceptors() ?? []
    )
  }

  internal func sendPayment<RequestStream>(
    _ requests: RequestStream,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncResponseStream<Lnrpc_SendResponse> where RequestStream: Sequence, RequestStream.Element == Lnrpc_SendRequest {
    return self.performAsyncBidirectionalStreamingCall(
      path: Lnrpc_LightningClientMetadata.Methods.sendPayment.path,
      requests: requests,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeSendPaymentInterceptors() ?? []
    )
  }

  internal func sendPayment<RequestStream>(
    _ requests: RequestStream,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncResponseStream<Lnrpc_SendResponse> where RequestStream: AsyncSequence & Sendable, RequestStream.Element == Lnrpc_SendRequest {
    return self.performAsyncBidirectionalStreamingCall(
      path: Lnrpc_LightningClientMetadata.Methods.sendPayment.path,
      requests: requests,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeSendPaymentInterceptors() ?? []
    )
  }

  internal func sendPaymentSync(
    _ request: Lnrpc_SendRequest,
    callOptions: CallOptions? = nil
  ) async throws -> Lnrpc_SendResponse {
    return try await self.performAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.sendPaymentSync.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeSendPaymentSyncInterceptors() ?? []
    )
  }

  internal func sendToRoute<RequestStream>(
    _ requests: RequestStream,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncResponseStream<Lnrpc_SendResponse> where RequestStream: Sequence, RequestStream.Element == Lnrpc_SendToRouteRequest {
    return self.performAsyncBidirectionalStreamingCall(
      path: Lnrpc_LightningClientMetadata.Methods.sendToRoute.path,
      requests: requests,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeSendToRouteInterceptors() ?? []
    )
  }

  internal func sendToRoute<RequestStream>(
    _ requests: RequestStream,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncResponseStream<Lnrpc_SendResponse> where RequestStream: AsyncSequence & Sendable, RequestStream.Element == Lnrpc_SendToRouteRequest {
    return self.performAsyncBidirectionalStreamingCall(
      path: Lnrpc_LightningClientMetadata.Methods.sendToRoute.path,
      requests: requests,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeSendToRouteInterceptors() ?? []
    )
  }

  internal func sendToRouteSync(
    _ request: Lnrpc_SendToRouteRequest,
    callOptions: CallOptions? = nil
  ) async throws -> Lnrpc_SendResponse {
    return try await self.performAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.sendToRouteSync.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeSendToRouteSyncInterceptors() ?? []
    )
  }

  internal func addInvoice(
    _ request: Lnrpc_Invoice,
    callOptions: CallOptions? = nil
  ) async throws -> Lnrpc_AddInvoiceResponse {
    return try await self.performAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.addInvoice.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeAddInvoiceInterceptors() ?? []
    )
  }

  internal func listInvoices(
    _ request: Lnrpc_ListInvoiceRequest,
    callOptions: CallOptions? = nil
  ) async throws -> Lnrpc_ListInvoiceResponse {
    return try await self.performAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.listInvoices.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeListInvoicesInterceptors() ?? []
    )
  }

  internal func lookupInvoice(
    _ request: Lnrpc_PaymentHash,
    callOptions: CallOptions? = nil
  ) async throws -> Lnrpc_Invoice {
    return try await self.performAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.lookupInvoice.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeLookupInvoiceInterceptors() ?? []
    )
  }

  internal func subscribeInvoices(
    _ request: Lnrpc_InvoiceSubscription,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncResponseStream<Lnrpc_Invoice> {
    return self.performAsyncServerStreamingCall(
      path: Lnrpc_LightningClientMetadata.Methods.subscribeInvoices.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeSubscribeInvoicesInterceptors() ?? []
    )
  }

  internal func decodePayReq(
    _ request: Lnrpc_PayReqString,
    callOptions: CallOptions? = nil
  ) async throws -> Lnrpc_PayReq {
    return try await self.performAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.decodePayReq.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeDecodePayReqInterceptors() ?? []
    )
  }

  internal func listPayments(
    _ request: Lnrpc_ListPaymentsRequest,
    callOptions: CallOptions? = nil
  ) async throws -> Lnrpc_ListPaymentsResponse {
    return try await self.performAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.listPayments.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeListPaymentsInterceptors() ?? []
    )
  }

  internal func deletePayment(
    _ request: Lnrpc_DeletePaymentRequest,
    callOptions: CallOptions? = nil
  ) async throws -> Lnrpc_DeletePaymentResponse {
    return try await self.performAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.deletePayment.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeDeletePaymentInterceptors() ?? []
    )
  }

  internal func deleteAllPayments(
    _ request: Lnrpc_DeleteAllPaymentsRequest,
    callOptions: CallOptions? = nil
  ) async throws -> Lnrpc_DeleteAllPaymentsResponse {
    return try await self.performAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.deleteAllPayments.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeDeleteAllPaymentsInterceptors() ?? []
    )
  }

  internal func describeGraph(
    _ request: Lnrpc_ChannelGraphRequest,
    callOptions: CallOptions? = nil
  ) async throws -> Lnrpc_ChannelGraph {
    return try await self.performAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.describeGraph.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeDescribeGraphInterceptors() ?? []
    )
  }

  internal func getNodeMetrics(
    _ request: Lnrpc_NodeMetricsRequest,
    callOptions: CallOptions? = nil
  ) async throws -> Lnrpc_NodeMetricsResponse {
    return try await self.performAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.getNodeMetrics.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeGetNodeMetricsInterceptors() ?? []
    )
  }

  internal func getChanInfo(
    _ request: Lnrpc_ChanInfoRequest,
    callOptions: CallOptions? = nil
  ) async throws -> Lnrpc_ChannelEdge {
    return try await self.performAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.getChanInfo.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeGetChanInfoInterceptors() ?? []
    )
  }

  internal func getNodeInfo(
    _ request: Lnrpc_NodeInfoRequest,
    callOptions: CallOptions? = nil
  ) async throws -> Lnrpc_NodeInfo {
    return try await self.performAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.getNodeInfo.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeGetNodeInfoInterceptors() ?? []
    )
  }

  internal func queryRoutes(
    _ request: Lnrpc_QueryRoutesRequest,
    callOptions: CallOptions? = nil
  ) async throws -> Lnrpc_QueryRoutesResponse {
    return try await self.performAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.queryRoutes.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeQueryRoutesInterceptors() ?? []
    )
  }

  internal func getNetworkInfo(
    _ request: Lnrpc_NetworkInfoRequest,
    callOptions: CallOptions? = nil
  ) async throws -> Lnrpc_NetworkInfo {
    return try await self.performAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.getNetworkInfo.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeGetNetworkInfoInterceptors() ?? []
    )
  }

  internal func stopDaemon(
    _ request: Lnrpc_StopRequest,
    callOptions: CallOptions? = nil
  ) async throws -> Lnrpc_StopResponse {
    return try await self.performAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.stopDaemon.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeStopDaemonInterceptors() ?? []
    )
  }

  internal func subscribeChannelGraph(
    _ request: Lnrpc_GraphTopologySubscription,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncResponseStream<Lnrpc_GraphTopologyUpdate> {
    return self.performAsyncServerStreamingCall(
      path: Lnrpc_LightningClientMetadata.Methods.subscribeChannelGraph.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeSubscribeChannelGraphInterceptors() ?? []
    )
  }

  internal func debugLevel(
    _ request: Lnrpc_DebugLevelRequest,
    callOptions: CallOptions? = nil
  ) async throws -> Lnrpc_DebugLevelResponse {
    return try await self.performAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.debugLevel.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeDebugLevelInterceptors() ?? []
    )
  }

  internal func feeReport(
    _ request: Lnrpc_FeeReportRequest,
    callOptions: CallOptions? = nil
  ) async throws -> Lnrpc_FeeReportResponse {
    return try await self.performAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.feeReport.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeFeeReportInterceptors() ?? []
    )
  }

  internal func updateChannelPolicy(
    _ request: Lnrpc_PolicyUpdateRequest,
    callOptions: CallOptions? = nil
  ) async throws -> Lnrpc_PolicyUpdateResponse {
    return try await self.performAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.updateChannelPolicy.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeUpdateChannelPolicyInterceptors() ?? []
    )
  }

  internal func forwardingHistory(
    _ request: Lnrpc_ForwardingHistoryRequest,
    callOptions: CallOptions? = nil
  ) async throws -> Lnrpc_ForwardingHistoryResponse {
    return try await self.performAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.forwardingHistory.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeForwardingHistoryInterceptors() ?? []
    )
  }

  internal func exportChannelBackup(
    _ request: Lnrpc_ExportChannelBackupRequest,
    callOptions: CallOptions? = nil
  ) async throws -> Lnrpc_ChannelBackup {
    return try await self.performAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.exportChannelBackup.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeExportChannelBackupInterceptors() ?? []
    )
  }

  internal func exportAllChannelBackups(
    _ request: Lnrpc_ChanBackupExportRequest,
    callOptions: CallOptions? = nil
  ) async throws -> Lnrpc_ChanBackupSnapshot {
    return try await self.performAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.exportAllChannelBackups.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeExportAllChannelBackupsInterceptors() ?? []
    )
  }

  internal func verifyChanBackup(
    _ request: Lnrpc_ChanBackupSnapshot,
    callOptions: CallOptions? = nil
  ) async throws -> Lnrpc_VerifyChanBackupResponse {
    return try await self.performAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.verifyChanBackup.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeVerifyChanBackupInterceptors() ?? []
    )
  }

  internal func restoreChannelBackups(
    _ request: Lnrpc_RestoreChanBackupRequest,
    callOptions: CallOptions? = nil
  ) async throws -> Lnrpc_RestoreBackupResponse {
    return try await self.performAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.restoreChannelBackups.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeRestoreChannelBackupsInterceptors() ?? []
    )
  }

  internal func subscribeChannelBackups(
    _ request: Lnrpc_ChannelBackupSubscription,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncResponseStream<Lnrpc_ChanBackupSnapshot> {
    return self.performAsyncServerStreamingCall(
      path: Lnrpc_LightningClientMetadata.Methods.subscribeChannelBackups.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeSubscribeChannelBackupsInterceptors() ?? []
    )
  }

  internal func bakeMacaroon(
    _ request: Lnrpc_BakeMacaroonRequest,
    callOptions: CallOptions? = nil
  ) async throws -> Lnrpc_BakeMacaroonResponse {
    return try await self.performAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.bakeMacaroon.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeBakeMacaroonInterceptors() ?? []
    )
  }

  internal func listMacaroonIDs(
    _ request: Lnrpc_ListMacaroonIDsRequest,
    callOptions: CallOptions? = nil
  ) async throws -> Lnrpc_ListMacaroonIDsResponse {
    return try await self.performAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.listMacaroonIDs.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeListMacaroonIDsInterceptors() ?? []
    )
  }

  internal func deleteMacaroonID(
    _ request: Lnrpc_DeleteMacaroonIDRequest,
    callOptions: CallOptions? = nil
  ) async throws -> Lnrpc_DeleteMacaroonIDResponse {
    return try await self.performAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.deleteMacaroonID.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeDeleteMacaroonIDInterceptors() ?? []
    )
  }

  internal func listPermissions(
    _ request: Lnrpc_ListPermissionsRequest,
    callOptions: CallOptions? = nil
  ) async throws -> Lnrpc_ListPermissionsResponse {
    return try await self.performAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.listPermissions.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeListPermissionsInterceptors() ?? []
    )
  }

  internal func checkMacaroonPermissions(
    _ request: Lnrpc_CheckMacPermRequest,
    callOptions: CallOptions? = nil
  ) async throws -> Lnrpc_CheckMacPermResponse {
    return try await self.performAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.checkMacaroonPermissions.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeCheckMacaroonPermissionsInterceptors() ?? []
    )
  }

  internal func registerRPCMiddleware<RequestStream>(
    _ requests: RequestStream,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncResponseStream<Lnrpc_RPCMiddlewareRequest> where RequestStream: Sequence, RequestStream.Element == Lnrpc_RPCMiddlewareResponse {
    return self.performAsyncBidirectionalStreamingCall(
      path: Lnrpc_LightningClientMetadata.Methods.registerRPCMiddleware.path,
      requests: requests,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeRegisterRPCMiddlewareInterceptors() ?? []
    )
  }

  internal func registerRPCMiddleware<RequestStream>(
    _ requests: RequestStream,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncResponseStream<Lnrpc_RPCMiddlewareRequest> where RequestStream: AsyncSequence & Sendable, RequestStream.Element == Lnrpc_RPCMiddlewareResponse {
    return self.performAsyncBidirectionalStreamingCall(
      path: Lnrpc_LightningClientMetadata.Methods.registerRPCMiddleware.path,
      requests: requests,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeRegisterRPCMiddlewareInterceptors() ?? []
    )
  }

  internal func sendCustomMessage(
    _ request: Lnrpc_SendCustomMessageRequest,
    callOptions: CallOptions? = nil
  ) async throws -> Lnrpc_SendCustomMessageResponse {
    return try await self.performAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.sendCustomMessage.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeSendCustomMessageInterceptors() ?? []
    )
  }

  internal func subscribeCustomMessages(
    _ request: Lnrpc_SubscribeCustomMessagesRequest,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncResponseStream<Lnrpc_CustomMessage> {
    return self.performAsyncServerStreamingCall(
      path: Lnrpc_LightningClientMetadata.Methods.subscribeCustomMessages.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeSubscribeCustomMessagesInterceptors() ?? []
    )
  }

  internal func listAliases(
    _ request: Lnrpc_ListAliasesRequest,
    callOptions: CallOptions? = nil
  ) async throws -> Lnrpc_ListAliasesResponse {
    return try await self.performAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.listAliases.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeListAliasesInterceptors() ?? []
    )
  }

  internal func lookupHtlcResolution(
    _ request: Lnrpc_LookupHtlcResolutionRequest,
    callOptions: CallOptions? = nil
  ) async throws -> Lnrpc_LookupHtlcResolutionResponse {
    return try await self.performAsyncUnaryCall(
      path: Lnrpc_LightningClientMetadata.Methods.lookupHtlcResolution.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeLookupHtlcResolutionInterceptors() ?? []
    )
  }
}

@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
internal struct Lnrpc_LightningAsyncClient: Lnrpc_LightningAsyncClientProtocol {
  internal var channel: GRPCChannel
  internal var defaultCallOptions: CallOptions
  internal var interceptors: Lnrpc_LightningClientInterceptorFactoryProtocol?

  internal init(
    channel: GRPCChannel,
    defaultCallOptions: CallOptions = CallOptions(),
    interceptors: Lnrpc_LightningClientInterceptorFactoryProtocol? = nil
  ) {
    self.channel = channel
    self.defaultCallOptions = defaultCallOptions
    self.interceptors = interceptors
  }
}

internal protocol Lnrpc_LightningClientInterceptorFactoryProtocol: Sendable {

  /// - Returns: Interceptors to use when invoking 'walletBalance'.
  func makeWalletBalanceInterceptors() -> [ClientInterceptor<Lnrpc_WalletBalanceRequest, Lnrpc_WalletBalanceResponse>]

  /// - Returns: Interceptors to use when invoking 'channelBalance'.
  func makeChannelBalanceInterceptors() -> [ClientInterceptor<Lnrpc_ChannelBalanceRequest, Lnrpc_ChannelBalanceResponse>]

  /// - Returns: Interceptors to use when invoking 'getTransactions'.
  func makeGetTransactionsInterceptors() -> [ClientInterceptor<Lnrpc_GetTransactionsRequest, Lnrpc_TransactionDetails>]

  /// - Returns: Interceptors to use when invoking 'estimateFee'.
  func makeEstimateFeeInterceptors() -> [ClientInterceptor<Lnrpc_EstimateFeeRequest, Lnrpc_EstimateFeeResponse>]

  /// - Returns: Interceptors to use when invoking 'sendCoins'.
  func makeSendCoinsInterceptors() -> [ClientInterceptor<Lnrpc_SendCoinsRequest, Lnrpc_SendCoinsResponse>]

  /// - Returns: Interceptors to use when invoking 'listUnspent'.
  func makeListUnspentInterceptors() -> [ClientInterceptor<Lnrpc_ListUnspentRequest, Lnrpc_ListUnspentResponse>]

  /// - Returns: Interceptors to use when invoking 'subscribeTransactions'.
  func makeSubscribeTransactionsInterceptors() -> [ClientInterceptor<Lnrpc_GetTransactionsRequest, Lnrpc_Transaction>]

  /// - Returns: Interceptors to use when invoking 'sendMany'.
  func makeSendManyInterceptors() -> [ClientInterceptor<Lnrpc_SendManyRequest, Lnrpc_SendManyResponse>]

  /// - Returns: Interceptors to use when invoking 'newAddress'.
  func makeNewAddressInterceptors() -> [ClientInterceptor<Lnrpc_NewAddressRequest, Lnrpc_NewAddressResponse>]

  /// - Returns: Interceptors to use when invoking 'signMessage'.
  func makeSignMessageInterceptors() -> [ClientInterceptor<Lnrpc_SignMessageRequest, Lnrpc_SignMessageResponse>]

  /// - Returns: Interceptors to use when invoking 'verifyMessage'.
  func makeVerifyMessageInterceptors() -> [ClientInterceptor<Lnrpc_VerifyMessageRequest, Lnrpc_VerifyMessageResponse>]

  /// - Returns: Interceptors to use when invoking 'connectPeer'.
  func makeConnectPeerInterceptors() -> [ClientInterceptor<Lnrpc_ConnectPeerRequest, Lnrpc_ConnectPeerResponse>]

  /// - Returns: Interceptors to use when invoking 'disconnectPeer'.
  func makeDisconnectPeerInterceptors() -> [ClientInterceptor<Lnrpc_DisconnectPeerRequest, Lnrpc_DisconnectPeerResponse>]

  /// - Returns: Interceptors to use when invoking 'listPeers'.
  func makeListPeersInterceptors() -> [ClientInterceptor<Lnrpc_ListPeersRequest, Lnrpc_ListPeersResponse>]

  /// - Returns: Interceptors to use when invoking 'subscribePeerEvents'.
  func makeSubscribePeerEventsInterceptors() -> [ClientInterceptor<Lnrpc_PeerEventSubscription, Lnrpc_PeerEvent>]

  /// - Returns: Interceptors to use when invoking 'getInfo'.
  func makeGetInfoInterceptors() -> [ClientInterceptor<Lnrpc_GetInfoRequest, Lnrpc_GetInfoResponse>]

  /// - Returns: Interceptors to use when invoking 'getRecoveryInfo'.
  func makeGetRecoveryInfoInterceptors() -> [ClientInterceptor<Lnrpc_GetRecoveryInfoRequest, Lnrpc_GetRecoveryInfoResponse>]

  /// - Returns: Interceptors to use when invoking 'pendingChannels'.
  func makePendingChannelsInterceptors() -> [ClientInterceptor<Lnrpc_PendingChannelsRequest, Lnrpc_PendingChannelsResponse>]

  /// - Returns: Interceptors to use when invoking 'listChannels'.
  func makeListChannelsInterceptors() -> [ClientInterceptor<Lnrpc_ListChannelsRequest, Lnrpc_ListChannelsResponse>]

  /// - Returns: Interceptors to use when invoking 'subscribeChannelEvents'.
  func makeSubscribeChannelEventsInterceptors() -> [ClientInterceptor<Lnrpc_ChannelEventSubscription, Lnrpc_ChannelEventUpdate>]

  /// - Returns: Interceptors to use when invoking 'closedChannels'.
  func makeClosedChannelsInterceptors() -> [ClientInterceptor<Lnrpc_ClosedChannelsRequest, Lnrpc_ClosedChannelsResponse>]

  /// - Returns: Interceptors to use when invoking 'openChannelSync'.
  func makeOpenChannelSyncInterceptors() -> [ClientInterceptor<Lnrpc_OpenChannelRequest, Lnrpc_ChannelPoint>]

  /// - Returns: Interceptors to use when invoking 'openChannel'.
  func makeOpenChannelInterceptors() -> [ClientInterceptor<Lnrpc_OpenChannelRequest, Lnrpc_OpenStatusUpdate>]

  /// - Returns: Interceptors to use when invoking 'batchOpenChannel'.
  func makeBatchOpenChannelInterceptors() -> [ClientInterceptor<Lnrpc_BatchOpenChannelRequest, Lnrpc_BatchOpenChannelResponse>]

  /// - Returns: Interceptors to use when invoking 'fundingStateStep'.
  func makeFundingStateStepInterceptors() -> [ClientInterceptor<Lnrpc_FundingTransitionMsg, Lnrpc_FundingStateStepResp>]

  /// - Returns: Interceptors to use when invoking 'channelAcceptor'.
  func makeChannelAcceptorInterceptors() -> [ClientInterceptor<Lnrpc_ChannelAcceptResponse, Lnrpc_ChannelAcceptRequest>]

  /// - Returns: Interceptors to use when invoking 'closeChannel'.
  func makeCloseChannelInterceptors() -> [ClientInterceptor<Lnrpc_CloseChannelRequest, Lnrpc_CloseStatusUpdate>]

  /// - Returns: Interceptors to use when invoking 'abandonChannel'.
  func makeAbandonChannelInterceptors() -> [ClientInterceptor<Lnrpc_AbandonChannelRequest, Lnrpc_AbandonChannelResponse>]

  /// - Returns: Interceptors to use when invoking 'sendPayment'.
  func makeSendPaymentInterceptors() -> [ClientInterceptor<Lnrpc_SendRequest, Lnrpc_SendResponse>]

  /// - Returns: Interceptors to use when invoking 'sendPaymentSync'.
  func makeSendPaymentSyncInterceptors() -> [ClientInterceptor<Lnrpc_SendRequest, Lnrpc_SendResponse>]

  /// - Returns: Interceptors to use when invoking 'sendToRoute'.
  func makeSendToRouteInterceptors() -> [ClientInterceptor<Lnrpc_SendToRouteRequest, Lnrpc_SendResponse>]

  /// - Returns: Interceptors to use when invoking 'sendToRouteSync'.
  func makeSendToRouteSyncInterceptors() -> [ClientInterceptor<Lnrpc_SendToRouteRequest, Lnrpc_SendResponse>]

  /// - Returns: Interceptors to use when invoking 'addInvoice'.
  func makeAddInvoiceInterceptors() -> [ClientInterceptor<Lnrpc_Invoice, Lnrpc_AddInvoiceResponse>]

  /// - Returns: Interceptors to use when invoking 'listInvoices'.
  func makeListInvoicesInterceptors() -> [ClientInterceptor<Lnrpc_ListInvoiceRequest, Lnrpc_ListInvoiceResponse>]

  /// - Returns: Interceptors to use when invoking 'lookupInvoice'.
  func makeLookupInvoiceInterceptors() -> [ClientInterceptor<Lnrpc_PaymentHash, Lnrpc_Invoice>]

  /// - Returns: Interceptors to use when invoking 'subscribeInvoices'.
  func makeSubscribeInvoicesInterceptors() -> [ClientInterceptor<Lnrpc_InvoiceSubscription, Lnrpc_Invoice>]

  /// - Returns: Interceptors to use when invoking 'decodePayReq'.
  func makeDecodePayReqInterceptors() -> [ClientInterceptor<Lnrpc_PayReqString, Lnrpc_PayReq>]

  /// - Returns: Interceptors to use when invoking 'listPayments'.
  func makeListPaymentsInterceptors() -> [ClientInterceptor<Lnrpc_ListPaymentsRequest, Lnrpc_ListPaymentsResponse>]

  /// - Returns: Interceptors to use when invoking 'deletePayment'.
  func makeDeletePaymentInterceptors() -> [ClientInterceptor<Lnrpc_DeletePaymentRequest, Lnrpc_DeletePaymentResponse>]

  /// - Returns: Interceptors to use when invoking 'deleteAllPayments'.
  func makeDeleteAllPaymentsInterceptors() -> [ClientInterceptor<Lnrpc_DeleteAllPaymentsRequest, Lnrpc_DeleteAllPaymentsResponse>]

  /// - Returns: Interceptors to use when invoking 'describeGraph'.
  func makeDescribeGraphInterceptors() -> [ClientInterceptor<Lnrpc_ChannelGraphRequest, Lnrpc_ChannelGraph>]

  /// - Returns: Interceptors to use when invoking 'getNodeMetrics'.
  func makeGetNodeMetricsInterceptors() -> [ClientInterceptor<Lnrpc_NodeMetricsRequest, Lnrpc_NodeMetricsResponse>]

  /// - Returns: Interceptors to use when invoking 'getChanInfo'.
  func makeGetChanInfoInterceptors() -> [ClientInterceptor<Lnrpc_ChanInfoRequest, Lnrpc_ChannelEdge>]

  /// - Returns: Interceptors to use when invoking 'getNodeInfo'.
  func makeGetNodeInfoInterceptors() -> [ClientInterceptor<Lnrpc_NodeInfoRequest, Lnrpc_NodeInfo>]

  /// - Returns: Interceptors to use when invoking 'queryRoutes'.
  func makeQueryRoutesInterceptors() -> [ClientInterceptor<Lnrpc_QueryRoutesRequest, Lnrpc_QueryRoutesResponse>]

  /// - Returns: Interceptors to use when invoking 'getNetworkInfo'.
  func makeGetNetworkInfoInterceptors() -> [ClientInterceptor<Lnrpc_NetworkInfoRequest, Lnrpc_NetworkInfo>]

  /// - Returns: Interceptors to use when invoking 'stopDaemon'.
  func makeStopDaemonInterceptors() -> [ClientInterceptor<Lnrpc_StopRequest, Lnrpc_StopResponse>]

  /// - Returns: Interceptors to use when invoking 'subscribeChannelGraph'.
  func makeSubscribeChannelGraphInterceptors() -> [ClientInterceptor<Lnrpc_GraphTopologySubscription, Lnrpc_GraphTopologyUpdate>]

  /// - Returns: Interceptors to use when invoking 'debugLevel'.
  func makeDebugLevelInterceptors() -> [ClientInterceptor<Lnrpc_DebugLevelRequest, Lnrpc_DebugLevelResponse>]

  /// - Returns: Interceptors to use when invoking 'feeReport'.
  func makeFeeReportInterceptors() -> [ClientInterceptor<Lnrpc_FeeReportRequest, Lnrpc_FeeReportResponse>]

  /// - Returns: Interceptors to use when invoking 'updateChannelPolicy'.
  func makeUpdateChannelPolicyInterceptors() -> [ClientInterceptor<Lnrpc_PolicyUpdateRequest, Lnrpc_PolicyUpdateResponse>]

  /// - Returns: Interceptors to use when invoking 'forwardingHistory'.
  func makeForwardingHistoryInterceptors() -> [ClientInterceptor<Lnrpc_ForwardingHistoryRequest, Lnrpc_ForwardingHistoryResponse>]

  /// - Returns: Interceptors to use when invoking 'exportChannelBackup'.
  func makeExportChannelBackupInterceptors() -> [ClientInterceptor<Lnrpc_ExportChannelBackupRequest, Lnrpc_ChannelBackup>]

  /// - Returns: Interceptors to use when invoking 'exportAllChannelBackups'.
  func makeExportAllChannelBackupsInterceptors() -> [ClientInterceptor<Lnrpc_ChanBackupExportRequest, Lnrpc_ChanBackupSnapshot>]

  /// - Returns: Interceptors to use when invoking 'verifyChanBackup'.
  func makeVerifyChanBackupInterceptors() -> [ClientInterceptor<Lnrpc_ChanBackupSnapshot, Lnrpc_VerifyChanBackupResponse>]

  /// - Returns: Interceptors to use when invoking 'restoreChannelBackups'.
  func makeRestoreChannelBackupsInterceptors() -> [ClientInterceptor<Lnrpc_RestoreChanBackupRequest, Lnrpc_RestoreBackupResponse>]

  /// - Returns: Interceptors to use when invoking 'subscribeChannelBackups'.
  func makeSubscribeChannelBackupsInterceptors() -> [ClientInterceptor<Lnrpc_ChannelBackupSubscription, Lnrpc_ChanBackupSnapshot>]

  /// - Returns: Interceptors to use when invoking 'bakeMacaroon'.
  func makeBakeMacaroonInterceptors() -> [ClientInterceptor<Lnrpc_BakeMacaroonRequest, Lnrpc_BakeMacaroonResponse>]

  /// - Returns: Interceptors to use when invoking 'listMacaroonIDs'.
  func makeListMacaroonIDsInterceptors() -> [ClientInterceptor<Lnrpc_ListMacaroonIDsRequest, Lnrpc_ListMacaroonIDsResponse>]

  /// - Returns: Interceptors to use when invoking 'deleteMacaroonID'.
  func makeDeleteMacaroonIDInterceptors() -> [ClientInterceptor<Lnrpc_DeleteMacaroonIDRequest, Lnrpc_DeleteMacaroonIDResponse>]

  /// - Returns: Interceptors to use when invoking 'listPermissions'.
  func makeListPermissionsInterceptors() -> [ClientInterceptor<Lnrpc_ListPermissionsRequest, Lnrpc_ListPermissionsResponse>]

  /// - Returns: Interceptors to use when invoking 'checkMacaroonPermissions'.
  func makeCheckMacaroonPermissionsInterceptors() -> [ClientInterceptor<Lnrpc_CheckMacPermRequest, Lnrpc_CheckMacPermResponse>]

  /// - Returns: Interceptors to use when invoking 'registerRPCMiddleware'.
  func makeRegisterRPCMiddlewareInterceptors() -> [ClientInterceptor<Lnrpc_RPCMiddlewareResponse, Lnrpc_RPCMiddlewareRequest>]

  /// - Returns: Interceptors to use when invoking 'sendCustomMessage'.
  func makeSendCustomMessageInterceptors() -> [ClientInterceptor<Lnrpc_SendCustomMessageRequest, Lnrpc_SendCustomMessageResponse>]

  /// - Returns: Interceptors to use when invoking 'subscribeCustomMessages'.
  func makeSubscribeCustomMessagesInterceptors() -> [ClientInterceptor<Lnrpc_SubscribeCustomMessagesRequest, Lnrpc_CustomMessage>]

  /// - Returns: Interceptors to use when invoking 'listAliases'.
  func makeListAliasesInterceptors() -> [ClientInterceptor<Lnrpc_ListAliasesRequest, Lnrpc_ListAliasesResponse>]

  /// - Returns: Interceptors to use when invoking 'lookupHtlcResolution'.
  func makeLookupHtlcResolutionInterceptors() -> [ClientInterceptor<Lnrpc_LookupHtlcResolutionRequest, Lnrpc_LookupHtlcResolutionResponse>]
}

internal enum Lnrpc_LightningClientMetadata {
  internal static let serviceDescriptor = GRPCServiceDescriptor(
    name: "Lightning",
    fullName: "lnrpc.Lightning",
    methods: [
      Lnrpc_LightningClientMetadata.Methods.walletBalance,
      Lnrpc_LightningClientMetadata.Methods.channelBalance,
      Lnrpc_LightningClientMetadata.Methods.getTransactions,
      Lnrpc_LightningClientMetadata.Methods.estimateFee,
      Lnrpc_LightningClientMetadata.Methods.sendCoins,
      Lnrpc_LightningClientMetadata.Methods.listUnspent,
      Lnrpc_LightningClientMetadata.Methods.subscribeTransactions,
      Lnrpc_LightningClientMetadata.Methods.sendMany,
      Lnrpc_LightningClientMetadata.Methods.newAddress,
      Lnrpc_LightningClientMetadata.Methods.signMessage,
      Lnrpc_LightningClientMetadata.Methods.verifyMessage,
      Lnrpc_LightningClientMetadata.Methods.connectPeer,
      Lnrpc_LightningClientMetadata.Methods.disconnectPeer,
      Lnrpc_LightningClientMetadata.Methods.listPeers,
      Lnrpc_LightningClientMetadata.Methods.subscribePeerEvents,
      Lnrpc_LightningClientMetadata.Methods.getInfo,
      Lnrpc_LightningClientMetadata.Methods.getRecoveryInfo,
      Lnrpc_LightningClientMetadata.Methods.pendingChannels,
      Lnrpc_LightningClientMetadata.Methods.listChannels,
      Lnrpc_LightningClientMetadata.Methods.subscribeChannelEvents,
      Lnrpc_LightningClientMetadata.Methods.closedChannels,
      Lnrpc_LightningClientMetadata.Methods.openChannelSync,
      Lnrpc_LightningClientMetadata.Methods.openChannel,
      Lnrpc_LightningClientMetadata.Methods.batchOpenChannel,
      Lnrpc_LightningClientMetadata.Methods.fundingStateStep,
      Lnrpc_LightningClientMetadata.Methods.channelAcceptor,
      Lnrpc_LightningClientMetadata.Methods.closeChannel,
      Lnrpc_LightningClientMetadata.Methods.abandonChannel,
      Lnrpc_LightningClientMetadata.Methods.sendPayment,
      Lnrpc_LightningClientMetadata.Methods.sendPaymentSync,
      Lnrpc_LightningClientMetadata.Methods.sendToRoute,
      Lnrpc_LightningClientMetadata.Methods.sendToRouteSync,
      Lnrpc_LightningClientMetadata.Methods.addInvoice,
      Lnrpc_LightningClientMetadata.Methods.listInvoices,
      Lnrpc_LightningClientMetadata.Methods.lookupInvoice,
      Lnrpc_LightningClientMetadata.Methods.subscribeInvoices,
      Lnrpc_LightningClientMetadata.Methods.decodePayReq,
      Lnrpc_LightningClientMetadata.Methods.listPayments,
      Lnrpc_LightningClientMetadata.Methods.deletePayment,
      Lnrpc_LightningClientMetadata.Methods.deleteAllPayments,
      Lnrpc_LightningClientMetadata.Methods.describeGraph,
      Lnrpc_LightningClientMetadata.Methods.getNodeMetrics,
      Lnrpc_LightningClientMetadata.Methods.getChanInfo,
      Lnrpc_LightningClientMetadata.Methods.getNodeInfo,
      Lnrpc_LightningClientMetadata.Methods.queryRoutes,
      Lnrpc_LightningClientMetadata.Methods.getNetworkInfo,
      Lnrpc_LightningClientMetadata.Methods.stopDaemon,
      Lnrpc_LightningClientMetadata.Methods.subscribeChannelGraph,
      Lnrpc_LightningClientMetadata.Methods.debugLevel,
      Lnrpc_LightningClientMetadata.Methods.feeReport,
      Lnrpc_LightningClientMetadata.Methods.updateChannelPolicy,
      Lnrpc_LightningClientMetadata.Methods.forwardingHistory,
      Lnrpc_LightningClientMetadata.Methods.exportChannelBackup,
      Lnrpc_LightningClientMetadata.Methods.exportAllChannelBackups,
      Lnrpc_LightningClientMetadata.Methods.verifyChanBackup,
      Lnrpc_LightningClientMetadata.Methods.restoreChannelBackups,
      Lnrpc_LightningClientMetadata.Methods.subscribeChannelBackups,
      Lnrpc_LightningClientMetadata.Methods.bakeMacaroon,
      Lnrpc_LightningClientMetadata.Methods.listMacaroonIDs,
      Lnrpc_LightningClientMetadata.Methods.deleteMacaroonID,
      Lnrpc_LightningClientMetadata.Methods.listPermissions,
      Lnrpc_LightningClientMetadata.Methods.checkMacaroonPermissions,
      Lnrpc_LightningClientMetadata.Methods.registerRPCMiddleware,
      Lnrpc_LightningClientMetadata.Methods.sendCustomMessage,
      Lnrpc_LightningClientMetadata.Methods.subscribeCustomMessages,
      Lnrpc_LightningClientMetadata.Methods.listAliases,
      Lnrpc_LightningClientMetadata.Methods.lookupHtlcResolution,
    ]
  )

  internal enum Methods {
    internal static let walletBalance = GRPCMethodDescriptor(
      name: "WalletBalance",
      path: "/lnrpc.Lightning/WalletBalance",
      type: GRPCCallType.unary
    )

    internal static let channelBalance = GRPCMethodDescriptor(
      name: "ChannelBalance",
      path: "/lnrpc.Lightning/ChannelBalance",
      type: GRPCCallType.unary
    )

    internal static let getTransactions = GRPCMethodDescriptor(
      name: "GetTransactions",
      path: "/lnrpc.Lightning/GetTransactions",
      type: GRPCCallType.unary
    )

    internal static let estimateFee = GRPCMethodDescriptor(
      name: "EstimateFee",
      path: "/lnrpc.Lightning/EstimateFee",
      type: GRPCCallType.unary
    )

    internal static let sendCoins = GRPCMethodDescriptor(
      name: "SendCoins",
      path: "/lnrpc.Lightning/SendCoins",
      type: GRPCCallType.unary
    )

    internal static let listUnspent = GRPCMethodDescriptor(
      name: "ListUnspent",
      path: "/lnrpc.Lightning/ListUnspent",
      type: GRPCCallType.unary
    )

    internal static let subscribeTransactions = GRPCMethodDescriptor(
      name: "SubscribeTransactions",
      path: "/lnrpc.Lightning/SubscribeTransactions",
      type: GRPCCallType.serverStreaming
    )

    internal static let sendMany = GRPCMethodDescriptor(
      name: "SendMany",
      path: "/lnrpc.Lightning/SendMany",
      type: GRPCCallType.unary
    )

    internal static let newAddress = GRPCMethodDescriptor(
      name: "NewAddress",
      path: "/lnrpc.Lightning/NewAddress",
      type: GRPCCallType.unary
    )

    internal static let signMessage = GRPCMethodDescriptor(
      name: "SignMessage",
      path: "/lnrpc.Lightning/SignMessage",
      type: GRPCCallType.unary
    )

    internal static let verifyMessage = GRPCMethodDescriptor(
      name: "VerifyMessage",
      path: "/lnrpc.Lightning/VerifyMessage",
      type: GRPCCallType.unary
    )

    internal static let connectPeer = GRPCMethodDescriptor(
      name: "ConnectPeer",
      path: "/lnrpc.Lightning/ConnectPeer",
      type: GRPCCallType.unary
    )

    internal static let disconnectPeer = GRPCMethodDescriptor(
      name: "DisconnectPeer",
      path: "/lnrpc.Lightning/DisconnectPeer",
      type: GRPCCallType.unary
    )

    internal static let listPeers = GRPCMethodDescriptor(
      name: "ListPeers",
      path: "/lnrpc.Lightning/ListPeers",
      type: GRPCCallType.unary
    )

    internal static let subscribePeerEvents = GRPCMethodDescriptor(
      name: "SubscribePeerEvents",
      path: "/lnrpc.Lightning/SubscribePeerEvents",
      type: GRPCCallType.serverStreaming
    )

    internal static let getInfo = GRPCMethodDescriptor(
      name: "GetInfo",
      path: "/lnrpc.Lightning/GetInfo",
      type: GRPCCallType.unary
    )

    internal static let getRecoveryInfo = GRPCMethodDescriptor(
      name: "GetRecoveryInfo",
      path: "/lnrpc.Lightning/GetRecoveryInfo",
      type: GRPCCallType.unary
    )

    internal static let pendingChannels = GRPCMethodDescriptor(
      name: "PendingChannels",
      path: "/lnrpc.Lightning/PendingChannels",
      type: GRPCCallType.unary
    )

    internal static let listChannels = GRPCMethodDescriptor(
      name: "ListChannels",
      path: "/lnrpc.Lightning/ListChannels",
      type: GRPCCallType.unary
    )

    internal static let subscribeChannelEvents = GRPCMethodDescriptor(
      name: "SubscribeChannelEvents",
      path: "/lnrpc.Lightning/SubscribeChannelEvents",
      type: GRPCCallType.serverStreaming
    )

    internal static let closedChannels = GRPCMethodDescriptor(
      name: "ClosedChannels",
      path: "/lnrpc.Lightning/ClosedChannels",
      type: GRPCCallType.unary
    )

    internal static let openChannelSync = GRPCMethodDescriptor(
      name: "OpenChannelSync",
      path: "/lnrpc.Lightning/OpenChannelSync",
      type: GRPCCallType.unary
    )

    internal static let openChannel = GRPCMethodDescriptor(
      name: "OpenChannel",
      path: "/lnrpc.Lightning/OpenChannel",
      type: GRPCCallType.serverStreaming
    )

    internal static let batchOpenChannel = GRPCMethodDescriptor(
      name: "BatchOpenChannel",
      path: "/lnrpc.Lightning/BatchOpenChannel",
      type: GRPCCallType.unary
    )

    internal static let fundingStateStep = GRPCMethodDescriptor(
      name: "FundingStateStep",
      path: "/lnrpc.Lightning/FundingStateStep",
      type: GRPCCallType.unary
    )

    internal static let channelAcceptor = GRPCMethodDescriptor(
      name: "ChannelAcceptor",
      path: "/lnrpc.Lightning/ChannelAcceptor",
      type: GRPCCallType.bidirectionalStreaming
    )

    internal static let closeChannel = GRPCMethodDescriptor(
      name: "CloseChannel",
      path: "/lnrpc.Lightning/CloseChannel",
      type: GRPCCallType.serverStreaming
    )

    internal static let abandonChannel = GRPCMethodDescriptor(
      name: "AbandonChannel",
      path: "/lnrpc.Lightning/AbandonChannel",
      type: GRPCCallType.unary
    )

    internal static let sendPayment = GRPCMethodDescriptor(
      name: "SendPayment",
      path: "/lnrpc.Lightning/SendPayment",
      type: GRPCCallType.bidirectionalStreaming
    )

    internal static let sendPaymentSync = GRPCMethodDescriptor(
      name: "SendPaymentSync",
      path: "/lnrpc.Lightning/SendPaymentSync",
      type: GRPCCallType.unary
    )

    internal static let sendToRoute = GRPCMethodDescriptor(
      name: "SendToRoute",
      path: "/lnrpc.Lightning/SendToRoute",
      type: GRPCCallType.bidirectionalStreaming
    )

    internal static let sendToRouteSync = GRPCMethodDescriptor(
      name: "SendToRouteSync",
      path: "/lnrpc.Lightning/SendToRouteSync",
      type: GRPCCallType.unary
    )

    internal static let addInvoice = GRPCMethodDescriptor(
      name: "AddInvoice",
      path: "/lnrpc.Lightning/AddInvoice",
      type: GRPCCallType.unary
    )

    internal static let listInvoices = GRPCMethodDescriptor(
      name: "ListInvoices",
      path: "/lnrpc.Lightning/ListInvoices",
      type: GRPCCallType.unary
    )

    internal static let lookupInvoice = GRPCMethodDescriptor(
      name: "LookupInvoice",
      path: "/lnrpc.Lightning/LookupInvoice",
      type: GRPCCallType.unary
    )

    internal static let subscribeInvoices = GRPCMethodDescriptor(
      name: "SubscribeInvoices",
      path: "/lnrpc.Lightning/SubscribeInvoices",
      type: GRPCCallType.serverStreaming
    )

    internal static let decodePayReq = GRPCMethodDescriptor(
      name: "DecodePayReq",
      path: "/lnrpc.Lightning/DecodePayReq",
      type: GRPCCallType.unary
    )

    internal static let listPayments = GRPCMethodDescriptor(
      name: "ListPayments",
      path: "/lnrpc.Lightning/ListPayments",
      type: GRPCCallType.unary
    )

    internal static let deletePayment = GRPCMethodDescriptor(
      name: "DeletePayment",
      path: "/lnrpc.Lightning/DeletePayment",
      type: GRPCCallType.unary
    )

    internal static let deleteAllPayments = GRPCMethodDescriptor(
      name: "DeleteAllPayments",
      path: "/lnrpc.Lightning/DeleteAllPayments",
      type: GRPCCallType.unary
    )

    internal static let describeGraph = GRPCMethodDescriptor(
      name: "DescribeGraph",
      path: "/lnrpc.Lightning/DescribeGraph",
      type: GRPCCallType.unary
    )

    internal static let getNodeMetrics = GRPCMethodDescriptor(
      name: "GetNodeMetrics",
      path: "/lnrpc.Lightning/GetNodeMetrics",
      type: GRPCCallType.unary
    )

    internal static let getChanInfo = GRPCMethodDescriptor(
      name: "GetChanInfo",
      path: "/lnrpc.Lightning/GetChanInfo",
      type: GRPCCallType.unary
    )

    internal static let getNodeInfo = GRPCMethodDescriptor(
      name: "GetNodeInfo",
      path: "/lnrpc.Lightning/GetNodeInfo",
      type: GRPCCallType.unary
    )

    internal static let queryRoutes = GRPCMethodDescriptor(
      name: "QueryRoutes",
      path: "/lnrpc.Lightning/QueryRoutes",
      type: GRPCCallType.unary
    )

    internal static let getNetworkInfo = GRPCMethodDescriptor(
      name: "GetNetworkInfo",
      path: "/lnrpc.Lightning/GetNetworkInfo",
      type: GRPCCallType.unary
    )

    internal static let stopDaemon = GRPCMethodDescriptor(
      name: "StopDaemon",
      path: "/lnrpc.Lightning/StopDaemon",
      type: GRPCCallType.unary
    )

    internal static let subscribeChannelGraph = GRPCMethodDescriptor(
      name: "SubscribeChannelGraph",
      path: "/lnrpc.Lightning/SubscribeChannelGraph",
      type: GRPCCallType.serverStreaming
    )

    internal static let debugLevel = GRPCMethodDescriptor(
      name: "DebugLevel",
      path: "/lnrpc.Lightning/DebugLevel",
      type: GRPCCallType.unary
    )

    internal static let feeReport = GRPCMethodDescriptor(
      name: "FeeReport",
      path: "/lnrpc.Lightning/FeeReport",
      type: GRPCCallType.unary
    )

    internal static let updateChannelPolicy = GRPCMethodDescriptor(
      name: "UpdateChannelPolicy",
      path: "/lnrpc.Lightning/UpdateChannelPolicy",
      type: GRPCCallType.unary
    )

    internal static let forwardingHistory = GRPCMethodDescriptor(
      name: "ForwardingHistory",
      path: "/lnrpc.Lightning/ForwardingHistory",
      type: GRPCCallType.unary
    )

    internal static let exportChannelBackup = GRPCMethodDescriptor(
      name: "ExportChannelBackup",
      path: "/lnrpc.Lightning/ExportChannelBackup",
      type: GRPCCallType.unary
    )

    internal static let exportAllChannelBackups = GRPCMethodDescriptor(
      name: "ExportAllChannelBackups",
      path: "/lnrpc.Lightning/ExportAllChannelBackups",
      type: GRPCCallType.unary
    )

    internal static let verifyChanBackup = GRPCMethodDescriptor(
      name: "VerifyChanBackup",
      path: "/lnrpc.Lightning/VerifyChanBackup",
      type: GRPCCallType.unary
    )

    internal static let restoreChannelBackups = GRPCMethodDescriptor(
      name: "RestoreChannelBackups",
      path: "/lnrpc.Lightning/RestoreChannelBackups",
      type: GRPCCallType.unary
    )

    internal static let subscribeChannelBackups = GRPCMethodDescriptor(
      name: "SubscribeChannelBackups",
      path: "/lnrpc.Lightning/SubscribeChannelBackups",
      type: GRPCCallType.serverStreaming
    )

    internal static let bakeMacaroon = GRPCMethodDescriptor(
      name: "BakeMacaroon",
      path: "/lnrpc.Lightning/BakeMacaroon",
      type: GRPCCallType.unary
    )

    internal static let listMacaroonIDs = GRPCMethodDescriptor(
      name: "ListMacaroonIDs",
      path: "/lnrpc.Lightning/ListMacaroonIDs",
      type: GRPCCallType.unary
    )

    internal static let deleteMacaroonID = GRPCMethodDescriptor(
      name: "DeleteMacaroonID",
      path: "/lnrpc.Lightning/DeleteMacaroonID",
      type: GRPCCallType.unary
    )

    internal static let listPermissions = GRPCMethodDescriptor(
      name: "ListPermissions",
      path: "/lnrpc.Lightning/ListPermissions",
      type: GRPCCallType.unary
    )

    internal static let checkMacaroonPermissions = GRPCMethodDescriptor(
      name: "CheckMacaroonPermissions",
      path: "/lnrpc.Lightning/CheckMacaroonPermissions",
      type: GRPCCallType.unary
    )

    internal static let registerRPCMiddleware = GRPCMethodDescriptor(
      name: "RegisterRPCMiddleware",
      path: "/lnrpc.Lightning/RegisterRPCMiddleware",
      type: GRPCCallType.bidirectionalStreaming
    )

    internal static let sendCustomMessage = GRPCMethodDescriptor(
      name: "SendCustomMessage",
      path: "/lnrpc.Lightning/SendCustomMessage",
      type: GRPCCallType.unary
    )

    internal static let subscribeCustomMessages = GRPCMethodDescriptor(
      name: "SubscribeCustomMessages",
      path: "/lnrpc.Lightning/SubscribeCustomMessages",
      type: GRPCCallType.serverStreaming
    )

    internal static let listAliases = GRPCMethodDescriptor(
      name: "ListAliases",
      path: "/lnrpc.Lightning/ListAliases",
      type: GRPCCallType.unary
    )

    internal static let lookupHtlcResolution = GRPCMethodDescriptor(
      name: "LookupHtlcResolution",
      path: "/lnrpc.Lightning/LookupHtlcResolution",
      type: GRPCCallType.unary
    )
  }
}

/// Lightning is the main RPC server of the daemon.
///
/// To build a server, implement a class that conforms to this protocol.
internal protocol Lnrpc_LightningProvider: CallHandlerProvider {
  var interceptors: Lnrpc_LightningServerInterceptorFactoryProtocol? { get }

  /// lncli: `walletbalance`
  ///WalletBalance returns total unspent outputs(confirmed and unconfirmed), all
  ///confirmed unspent outputs and all unconfirmed unspent outputs under control
  ///of the wallet.
  func walletBalance(request: Lnrpc_WalletBalanceRequest, context: StatusOnlyCallContext) -> EventLoopFuture<Lnrpc_WalletBalanceResponse>

  /// lncli: `channelbalance`
  ///ChannelBalance returns a report on the total funds across all open channels,
  ///categorized in local/remote, pending local/remote and unsettled local/remote
  ///balances.
  func channelBalance(request: Lnrpc_ChannelBalanceRequest, context: StatusOnlyCallContext) -> EventLoopFuture<Lnrpc_ChannelBalanceResponse>

  /// lncli: `listchaintxns`
  ///GetTransactions returns a list describing all the known transactions
  ///relevant to the wallet.
  func getTransactions(request: Lnrpc_GetTransactionsRequest, context: StatusOnlyCallContext) -> EventLoopFuture<Lnrpc_TransactionDetails>

  /// lncli: `estimatefee`
  ///EstimateFee asks the chain backend to estimate the fee rate and total fees
  ///for a transaction that pays to multiple specified outputs.
  ///
  ///When using REST, the `AddrToAmount` map type can be set by appending
  ///`&AddrToAmount[<address>]=<amount_to_send>` to the URL. Unfortunately this
  ///map type doesn't appear in the REST API documentation because of a bug in
  ///the grpc-gateway library.
  func estimateFee(request: Lnrpc_EstimateFeeRequest, context: StatusOnlyCallContext) -> EventLoopFuture<Lnrpc_EstimateFeeResponse>

  /// lncli: `sendcoins`
  ///SendCoins executes a request to send coins to a particular address. Unlike
  ///SendMany, this RPC call only allows creating a single output at a time. If
  ///neither target_conf, or sat_per_vbyte are set, then the internal wallet will
  ///consult its fee model to determine a fee for the default confirmation
  ///target.
  func sendCoins(request: Lnrpc_SendCoinsRequest, context: StatusOnlyCallContext) -> EventLoopFuture<Lnrpc_SendCoinsResponse>

  /// lncli: `listunspent`
  ///Deprecated, use walletrpc.ListUnspent instead.
  ///
  ///ListUnspent returns a list of all utxos spendable by the wallet with a
  ///number of confirmations between the specified minimum and maximum.
  func listUnspent(request: Lnrpc_ListUnspentRequest, context: StatusOnlyCallContext) -> EventLoopFuture<Lnrpc_ListUnspentResponse>

  ///
  ///SubscribeTransactions creates a uni-directional stream from the server to
  ///the client in which any newly discovered transactions relevant to the
  ///wallet are sent over.
  func subscribeTransactions(request: Lnrpc_GetTransactionsRequest, context: StreamingResponseCallContext<Lnrpc_Transaction>) -> EventLoopFuture<GRPCStatus>

  /// lncli: `sendmany`
  ///SendMany handles a request for a transaction that creates multiple specified
  ///outputs in parallel. If neither target_conf, or sat_per_vbyte are set, then
  ///the internal wallet will consult its fee model to determine a fee for the
  ///default confirmation target.
  func sendMany(request: Lnrpc_SendManyRequest, context: StatusOnlyCallContext) -> EventLoopFuture<Lnrpc_SendManyResponse>

  /// lncli: `newaddress`
  ///NewAddress creates a new address under control of the local wallet.
  func newAddress(request: Lnrpc_NewAddressRequest, context: StatusOnlyCallContext) -> EventLoopFuture<Lnrpc_NewAddressResponse>

  /// lncli: `signmessage`
  ///SignMessage signs a message with this node's private key. The returned
  ///signature string is `zbase32` encoded and pubkey recoverable, meaning that
  ///only the message digest and signature are needed for verification.
  func signMessage(request: Lnrpc_SignMessageRequest, context: StatusOnlyCallContext) -> EventLoopFuture<Lnrpc_SignMessageResponse>

  /// lncli: `verifymessage`
  ///VerifyMessage verifies a signature over a message and recovers the signer's
  ///public key. The signature is only deemed valid if the recovered public key
  ///corresponds to a node key in the public Lightning network. The signature
  ///must be zbase32 encoded and signed by an active node in the resident node's
  ///channel database. In addition to returning the validity of the signature,
  ///VerifyMessage also returns the recovered pubkey from the signature.
  func verifyMessage(request: Lnrpc_VerifyMessageRequest, context: StatusOnlyCallContext) -> EventLoopFuture<Lnrpc_VerifyMessageResponse>

  /// lncli: `connect`
  ///ConnectPeer attempts to establish a connection to a remote peer. This is at
  ///the networking level, and is used for communication between nodes. This is
  ///distinct from establishing a channel with a peer.
  func connectPeer(request: Lnrpc_ConnectPeerRequest, context: StatusOnlyCallContext) -> EventLoopFuture<Lnrpc_ConnectPeerResponse>

  /// lncli: `disconnect`
  ///DisconnectPeer attempts to disconnect one peer from another identified by a
  ///given pubKey. In the case that we currently have a pending or active channel
  ///with the target peer, then this action will be not be allowed.
  func disconnectPeer(request: Lnrpc_DisconnectPeerRequest, context: StatusOnlyCallContext) -> EventLoopFuture<Lnrpc_DisconnectPeerResponse>

  /// lncli: `listpeers`
  ///ListPeers returns a verbose listing of all currently active peers.
  func listPeers(request: Lnrpc_ListPeersRequest, context: StatusOnlyCallContext) -> EventLoopFuture<Lnrpc_ListPeersResponse>

  ///
  ///SubscribePeerEvents creates a uni-directional stream from the server to
  ///the client in which any events relevant to the state of peers are sent
  ///over. Events include peers going online and offline.
  func subscribePeerEvents(request: Lnrpc_PeerEventSubscription, context: StreamingResponseCallContext<Lnrpc_PeerEvent>) -> EventLoopFuture<GRPCStatus>

  /// lncli: `getinfo`
  ///GetInfo returns general information concerning the lightning node including
  ///it's identity pubkey, alias, the chains it is connected to, and information
  ///concerning the number of open+pending channels.
  func getInfo(request: Lnrpc_GetInfoRequest, context: StatusOnlyCallContext) -> EventLoopFuture<Lnrpc_GetInfoResponse>

  ///* lncli: `getrecoveryinfo`
  ///GetRecoveryInfo returns information concerning the recovery mode including
  ///whether it's in a recovery mode, whether the recovery is finished, and the
  ///progress made so far.
  func getRecoveryInfo(request: Lnrpc_GetRecoveryInfoRequest, context: StatusOnlyCallContext) -> EventLoopFuture<Lnrpc_GetRecoveryInfoResponse>

  /// lncli: `pendingchannels`
  ///PendingChannels returns a list of all the channels that are currently
  ///considered "pending". A channel is pending if it has finished the funding
  ///workflow and is waiting for confirmations for the funding txn, or is in the
  ///process of closure, either initiated cooperatively or non-cooperatively.
  func pendingChannels(request: Lnrpc_PendingChannelsRequest, context: StatusOnlyCallContext) -> EventLoopFuture<Lnrpc_PendingChannelsResponse>

  /// lncli: `listchannels`
  ///ListChannels returns a description of all the open channels that this node
  ///is a participant in.
  func listChannels(request: Lnrpc_ListChannelsRequest, context: StatusOnlyCallContext) -> EventLoopFuture<Lnrpc_ListChannelsResponse>

  ///
  ///SubscribeChannelEvents creates a uni-directional stream from the server to
  ///the client in which any updates relevant to the state of the channels are
  ///sent over. Events include new active channels, inactive channels, and closed
  ///channels.
  func subscribeChannelEvents(request: Lnrpc_ChannelEventSubscription, context: StreamingResponseCallContext<Lnrpc_ChannelEventUpdate>) -> EventLoopFuture<GRPCStatus>

  /// lncli: `closedchannels`
  ///ClosedChannels returns a description of all the closed channels that
  ///this node was a participant in.
  func closedChannels(request: Lnrpc_ClosedChannelsRequest, context: StatusOnlyCallContext) -> EventLoopFuture<Lnrpc_ClosedChannelsResponse>

  ///
  ///OpenChannelSync is a synchronous version of the OpenChannel RPC call. This
  ///call is meant to be consumed by clients to the REST proxy. As with all
  ///other sync calls, all byte slices are intended to be populated as hex
  ///encoded strings.
  func openChannelSync(request: Lnrpc_OpenChannelRequest, context: StatusOnlyCallContext) -> EventLoopFuture<Lnrpc_ChannelPoint>

  /// lncli: `openchannel`
  ///OpenChannel attempts to open a singly funded channel specified in the
  ///request to a remote peer. Users are able to specify a target number of
  ///blocks that the funding transaction should be confirmed in, or a manual fee
  ///rate to us for the funding transaction. If neither are specified, then a
  ///lax block confirmation target is used. Each OpenStatusUpdate will return
  ///the pending channel ID of the in-progress channel. Depending on the
  ///arguments specified in the OpenChannelRequest, this pending channel ID can
  ///then be used to manually progress the channel funding flow.
  func openChannel(request: Lnrpc_OpenChannelRequest, context: StreamingResponseCallContext<Lnrpc_OpenStatusUpdate>) -> EventLoopFuture<GRPCStatus>

  /// lncli: `batchopenchannel`
  ///BatchOpenChannel attempts to open multiple single-funded channels in a
  ///single transaction in an atomic way. This means either all channel open
  ///requests succeed at once or all attempts are aborted if any of them fail.
  ///This is the safer variant of using PSBTs to manually fund a batch of
  ///channels through the OpenChannel RPC.
  func batchOpenChannel(request: Lnrpc_BatchOpenChannelRequest, context: StatusOnlyCallContext) -> EventLoopFuture<Lnrpc_BatchOpenChannelResponse>

  ///
  ///FundingStateStep is an advanced funding related call that allows the caller
  ///to either execute some preparatory steps for a funding workflow, or
  ///manually progress a funding workflow. The primary way a funding flow is
  ///identified is via its pending channel ID. As an example, this method can be
  ///used to specify that we're expecting a funding flow for a particular
  ///pending channel ID, for which we need to use specific parameters.
  ///Alternatively, this can be used to interactively drive PSBT signing for
  ///funding for partially complete funding transactions.
  func fundingStateStep(request: Lnrpc_FundingTransitionMsg, context: StatusOnlyCallContext) -> EventLoopFuture<Lnrpc_FundingStateStepResp>

  ///
  ///ChannelAcceptor dispatches a bi-directional streaming RPC in which
  ///OpenChannel requests are sent to the client and the client responds with
  ///a boolean that tells LND whether or not to accept the channel. This allows
  ///node operators to specify their own criteria for accepting inbound channels
  ///through a single persistent connection.
  func channelAcceptor(context: StreamingResponseCallContext<Lnrpc_ChannelAcceptRequest>) -> EventLoopFuture<(StreamEvent<Lnrpc_ChannelAcceptResponse>) -> Void>

  /// lncli: `closechannel`
  ///CloseChannel attempts to close an active channel identified by its channel
  ///outpoint (ChannelPoint). The actions of this method can additionally be
  ///augmented to attempt a force close after a timeout period in the case of an
  ///inactive peer. If a non-force close (cooperative closure) is requested,
  ///then the user can specify either a target number of blocks until the
  ///closure transaction is confirmed, or a manual fee rate. If neither are
  ///specified, then a default lax, block confirmation target is used.
  func closeChannel(request: Lnrpc_CloseChannelRequest, context: StreamingResponseCallContext<Lnrpc_CloseStatusUpdate>) -> EventLoopFuture<GRPCStatus>

  /// lncli: `abandonchannel`
  ///AbandonChannel removes all channel state from the database except for a
  ///close summary. This method can be used to get rid of permanently unusable
  ///channels due to bugs fixed in newer versions of lnd. This method can also be
  ///used to remove externally funded channels where the funding transaction was
  ///never broadcast. Only available for non-externally funded channels in dev
  ///build.
  func abandonChannel(request: Lnrpc_AbandonChannelRequest, context: StatusOnlyCallContext) -> EventLoopFuture<Lnrpc_AbandonChannelResponse>

  /// lncli: `sendpayment`
  ///Deprecated, use routerrpc.SendPaymentV2. SendPayment dispatches a
  ///bi-directional streaming RPC for sending payments through the Lightning
  ///Network. A single RPC invocation creates a persistent bi-directional
  ///stream allowing clients to rapidly send payments through the Lightning
  ///Network with a single persistent connection.
  func sendPayment(context: StreamingResponseCallContext<Lnrpc_SendResponse>) -> EventLoopFuture<(StreamEvent<Lnrpc_SendRequest>) -> Void>

  ///
  ///SendPaymentSync is the synchronous non-streaming version of SendPayment.
  ///This RPC is intended to be consumed by clients of the REST proxy.
  ///Additionally, this RPC expects the destination's public key and the payment
  ///hash (if any) to be encoded as hex strings.
  func sendPaymentSync(request: Lnrpc_SendRequest, context: StatusOnlyCallContext) -> EventLoopFuture<Lnrpc_SendResponse>

  /// lncli: `sendtoroute`
  ///Deprecated, use routerrpc.SendToRouteV2. SendToRoute is a bi-directional
  ///streaming RPC for sending payment through the Lightning Network. This
  ///method differs from SendPayment in that it allows users to specify a full
  ///route manually. This can be used for things like rebalancing, and atomic
  ///swaps.
  func sendToRoute(context: StreamingResponseCallContext<Lnrpc_SendResponse>) -> EventLoopFuture<(StreamEvent<Lnrpc_SendToRouteRequest>) -> Void>

  ///
  ///SendToRouteSync is a synchronous version of SendToRoute. It Will block
  ///until the payment either fails or succeeds.
  func sendToRouteSync(request: Lnrpc_SendToRouteRequest, context: StatusOnlyCallContext) -> EventLoopFuture<Lnrpc_SendResponse>

  /// lncli: `addinvoice`
  ///AddInvoice attempts to add a new invoice to the invoice database. Any
  ///duplicated invoices are rejected, therefore all invoices *must* have a
  ///unique payment preimage.
  func addInvoice(request: Lnrpc_Invoice, context: StatusOnlyCallContext) -> EventLoopFuture<Lnrpc_AddInvoiceResponse>

  /// lncli: `listinvoices`
  ///ListInvoices returns a list of all the invoices currently stored within the
  ///database. Any active debug invoices are ignored. It has full support for
  ///paginated responses, allowing users to query for specific invoices through
  ///their add_index. This can be done by using either the first_index_offset or
  ///last_index_offset fields included in the response as the index_offset of the
  ///next request. By default, the first 100 invoices created will be returned.
  ///Backwards pagination is also supported through the Reversed flag.
  func listInvoices(request: Lnrpc_ListInvoiceRequest, context: StatusOnlyCallContext) -> EventLoopFuture<Lnrpc_ListInvoiceResponse>

  /// lncli: `lookupinvoice`
  ///LookupInvoice attempts to look up an invoice according to its payment hash.
  ///The passed payment hash *must* be exactly 32 bytes, if not, an error is
  ///returned.
  func lookupInvoice(request: Lnrpc_PaymentHash, context: StatusOnlyCallContext) -> EventLoopFuture<Lnrpc_Invoice>

  ///
  ///SubscribeInvoices returns a uni-directional stream (server -> client) for
  ///notifying the client of newly added/settled invoices. The caller can
  ///optionally specify the add_index and/or the settle_index. If the add_index
  ///is specified, then we'll first start by sending add invoice events for all
  ///invoices with an add_index greater than the specified value. If the
  ///settle_index is specified, the next, we'll send out all settle events for
  ///invoices with a settle_index greater than the specified value. One or both
  ///of these fields can be set. If no fields are set, then we'll only send out
  ///the latest add/settle events.
  func subscribeInvoices(request: Lnrpc_InvoiceSubscription, context: StreamingResponseCallContext<Lnrpc_Invoice>) -> EventLoopFuture<GRPCStatus>

  /// lncli: `decodepayreq`
  ///DecodePayReq takes an encoded payment request string and attempts to decode
  ///it, returning a full description of the conditions encoded within the
  ///payment request.
  func decodePayReq(request: Lnrpc_PayReqString, context: StatusOnlyCallContext) -> EventLoopFuture<Lnrpc_PayReq>

  /// lncli: `listpayments`
  ///ListPayments returns a list of all outgoing payments.
  func listPayments(request: Lnrpc_ListPaymentsRequest, context: StatusOnlyCallContext) -> EventLoopFuture<Lnrpc_ListPaymentsResponse>

  ///
  ///DeletePayment deletes an outgoing payment from DB. Note that it will not
  ///attempt to delete an In-Flight payment, since that would be unsafe.
  func deletePayment(request: Lnrpc_DeletePaymentRequest, context: StatusOnlyCallContext) -> EventLoopFuture<Lnrpc_DeletePaymentResponse>

  ///
  ///DeleteAllPayments deletes all outgoing payments from DB. Note that it will
  ///not attempt to delete In-Flight payments, since that would be unsafe.
  func deleteAllPayments(request: Lnrpc_DeleteAllPaymentsRequest, context: StatusOnlyCallContext) -> EventLoopFuture<Lnrpc_DeleteAllPaymentsResponse>

  /// lncli: `describegraph`
  ///DescribeGraph returns a description of the latest graph state from the
  ///point of view of the node. The graph information is partitioned into two
  ///components: all the nodes/vertexes, and all the edges that connect the
  ///vertexes themselves. As this is a directed graph, the edges also contain
  ///the node directional specific routing policy which includes: the time lock
  ///delta, fee information, etc.
  func describeGraph(request: Lnrpc_ChannelGraphRequest, context: StatusOnlyCallContext) -> EventLoopFuture<Lnrpc_ChannelGraph>

  /// lncli: `getnodemetrics`
  ///GetNodeMetrics returns node metrics calculated from the graph. Currently
  ///the only supported metric is betweenness centrality of individual nodes.
  func getNodeMetrics(request: Lnrpc_NodeMetricsRequest, context: StatusOnlyCallContext) -> EventLoopFuture<Lnrpc_NodeMetricsResponse>

  /// lncli: `getchaninfo`
  ///GetChanInfo returns the latest authenticated network announcement for the
  ///given channel identified by its channel ID: an 8-byte integer which
  ///uniquely identifies the location of transaction's funding output within the
  ///blockchain.
  func getChanInfo(request: Lnrpc_ChanInfoRequest, context: StatusOnlyCallContext) -> EventLoopFuture<Lnrpc_ChannelEdge>

  /// lncli: `getnodeinfo`
  ///GetNodeInfo returns the latest advertised, aggregated, and authenticated
  ///channel information for the specified node identified by its public key.
  func getNodeInfo(request: Lnrpc_NodeInfoRequest, context: StatusOnlyCallContext) -> EventLoopFuture<Lnrpc_NodeInfo>

  /// lncli: `queryroutes`
  ///QueryRoutes attempts to query the daemon's Channel Router for a possible
  ///route to a target destination capable of carrying a specific amount of
  ///satoshis. The returned route contains the full details required to craft and
  ///send an HTLC, also including the necessary information that should be
  ///present within the Sphinx packet encapsulated within the HTLC.
  ///
  ///When using REST, the `dest_custom_records` map type can be set by appending
  ///`&dest_custom_records[<record_number>]=<record_data_base64_url_encoded>`
  ///to the URL. Unfortunately this map type doesn't appear in the REST API
  ///documentation because of a bug in the grpc-gateway library.
  func queryRoutes(request: Lnrpc_QueryRoutesRequest, context: StatusOnlyCallContext) -> EventLoopFuture<Lnrpc_QueryRoutesResponse>

  /// lncli: `getnetworkinfo`
  ///GetNetworkInfo returns some basic stats about the known channel graph from
  ///the point of view of the node.
  func getNetworkInfo(request: Lnrpc_NetworkInfoRequest, context: StatusOnlyCallContext) -> EventLoopFuture<Lnrpc_NetworkInfo>

  /// lncli: `stop`
  ///StopDaemon will send a shutdown request to the interrupt handler, triggering
  ///a graceful shutdown of the daemon.
  func stopDaemon(request: Lnrpc_StopRequest, context: StatusOnlyCallContext) -> EventLoopFuture<Lnrpc_StopResponse>

  ///
  ///SubscribeChannelGraph launches a streaming RPC that allows the caller to
  ///receive notifications upon any changes to the channel graph topology from
  ///the point of view of the responding node. Events notified include: new
  ///nodes coming online, nodes updating their authenticated attributes, new
  ///channels being advertised, updates in the routing policy for a directional
  ///channel edge, and when channels are closed on-chain.
  func subscribeChannelGraph(request: Lnrpc_GraphTopologySubscription, context: StreamingResponseCallContext<Lnrpc_GraphTopologyUpdate>) -> EventLoopFuture<GRPCStatus>

  /// lncli: `debuglevel`
  ///DebugLevel allows a caller to programmatically set the logging verbosity of
  ///lnd. The logging can be targeted according to a coarse daemon-wide logging
  ///level, or in a granular fashion to specify the logging for a target
  ///sub-system.
  func debugLevel(request: Lnrpc_DebugLevelRequest, context: StatusOnlyCallContext) -> EventLoopFuture<Lnrpc_DebugLevelResponse>

  /// lncli: `feereport`
  ///FeeReport allows the caller to obtain a report detailing the current fee
  ///schedule enforced by the node globally for each channel.
  func feeReport(request: Lnrpc_FeeReportRequest, context: StatusOnlyCallContext) -> EventLoopFuture<Lnrpc_FeeReportResponse>

  /// lncli: `updatechanpolicy`
  ///UpdateChannelPolicy allows the caller to update the fee schedule and
  ///channel policies for all channels globally, or a particular channel.
  func updateChannelPolicy(request: Lnrpc_PolicyUpdateRequest, context: StatusOnlyCallContext) -> EventLoopFuture<Lnrpc_PolicyUpdateResponse>

  /// lncli: `fwdinghistory`
  ///ForwardingHistory allows the caller to query the htlcswitch for a record of
  ///all HTLCs forwarded within the target time range, and integer offset
  ///within that time range, for a maximum number of events. If no maximum number
  ///of events is specified, up to 100 events will be returned. If no time-range
  ///is specified, then events will be returned in the order that they occured.
  ///
  ///A list of forwarding events are returned. The size of each forwarding event
  ///is 40 bytes, and the max message size able to be returned in gRPC is 4 MiB.
  ///As a result each message can only contain 50k entries. Each response has
  ///the index offset of the last entry. The index offset can be provided to the
  ///request to allow the caller to skip a series of records.
  func forwardingHistory(request: Lnrpc_ForwardingHistoryRequest, context: StatusOnlyCallContext) -> EventLoopFuture<Lnrpc_ForwardingHistoryResponse>

  /// lncli: `exportchanbackup`
  ///ExportChannelBackup attempts to return an encrypted static channel backup
  ///for the target channel identified by it channel point. The backup is
  ///encrypted with a key generated from the aezeed seed of the user. The
  ///returned backup can either be restored using the RestoreChannelBackup
  ///method once lnd is running, or via the InitWallet and UnlockWallet methods
  ///from the WalletUnlocker service.
  func exportChannelBackup(request: Lnrpc_ExportChannelBackupRequest, context: StatusOnlyCallContext) -> EventLoopFuture<Lnrpc_ChannelBackup>

  ///
  ///ExportAllChannelBackups returns static channel backups for all existing
  ///channels known to lnd. A set of regular singular static channel backups for
  ///each channel are returned. Additionally, a multi-channel backup is returned
  ///as well, which contains a single encrypted blob containing the backups of
  ///each channel.
  func exportAllChannelBackups(request: Lnrpc_ChanBackupExportRequest, context: StatusOnlyCallContext) -> EventLoopFuture<Lnrpc_ChanBackupSnapshot>

  ///
  ///VerifyChanBackup allows a caller to verify the integrity of a channel backup
  ///snapshot. This method will accept either a packed Single or a packed Multi.
  ///Specifying both will result in an error.
  func verifyChanBackup(request: Lnrpc_ChanBackupSnapshot, context: StatusOnlyCallContext) -> EventLoopFuture<Lnrpc_VerifyChanBackupResponse>

  /// lncli: `restorechanbackup`
  ///RestoreChannelBackups accepts a set of singular channel backups, or a
  ///single encrypted multi-chan backup and attempts to recover any funds
  ///remaining within the channel. If we are able to unpack the backup, then the
  ///new channel will be shown under listchannels, as well as pending channels.
  func restoreChannelBackups(request: Lnrpc_RestoreChanBackupRequest, context: StatusOnlyCallContext) -> EventLoopFuture<Lnrpc_RestoreBackupResponse>

  ///
  ///SubscribeChannelBackups allows a client to sub-subscribe to the most up to
  ///date information concerning the state of all channel backups. Each time a
  ///new channel is added, we return the new set of channels, along with a
  ///multi-chan backup containing the backup info for all channels. Each time a
  ///channel is closed, we send a new update, which contains new new chan back
  ///ups, but the updated set of encrypted multi-chan backups with the closed
  ///channel(s) removed.
  func subscribeChannelBackups(request: Lnrpc_ChannelBackupSubscription, context: StreamingResponseCallContext<Lnrpc_ChanBackupSnapshot>) -> EventLoopFuture<GRPCStatus>

  /// lncli: `bakemacaroon`
  ///BakeMacaroon allows the creation of a new macaroon with custom read and
  ///write permissions. No first-party caveats are added since this can be done
  ///offline.
  func bakeMacaroon(request: Lnrpc_BakeMacaroonRequest, context: StatusOnlyCallContext) -> EventLoopFuture<Lnrpc_BakeMacaroonResponse>

  /// lncli: `listmacaroonids`
  ///ListMacaroonIDs returns all root key IDs that are in use.
  func listMacaroonIDs(request: Lnrpc_ListMacaroonIDsRequest, context: StatusOnlyCallContext) -> EventLoopFuture<Lnrpc_ListMacaroonIDsResponse>

  /// lncli: `deletemacaroonid`
  ///DeleteMacaroonID deletes the specified macaroon ID and invalidates all
  ///macaroons derived from that ID.
  func deleteMacaroonID(request: Lnrpc_DeleteMacaroonIDRequest, context: StatusOnlyCallContext) -> EventLoopFuture<Lnrpc_DeleteMacaroonIDResponse>

  /// lncli: `listpermissions`
  ///ListPermissions lists all RPC method URIs and their required macaroon
  ///permissions to access them.
  func listPermissions(request: Lnrpc_ListPermissionsRequest, context: StatusOnlyCallContext) -> EventLoopFuture<Lnrpc_ListPermissionsResponse>

  ///
  ///CheckMacaroonPermissions checks whether a request follows the constraints
  ///imposed on the macaroon and that the macaroon is authorized to follow the
  ///provided permissions.
  func checkMacaroonPermissions(request: Lnrpc_CheckMacPermRequest, context: StatusOnlyCallContext) -> EventLoopFuture<Lnrpc_CheckMacPermResponse>

  ///
  ///RegisterRPCMiddleware adds a new gRPC middleware to the interceptor chain. A
  ///gRPC middleware is software component external to lnd that aims to add
  ///additional business logic to lnd by observing/intercepting/validating
  ///incoming gRPC client requests and (if needed) replacing/overwriting outgoing
  ///messages before they're sent to the client. When registering the middleware
  ///must identify itself and indicate what custom macaroon caveats it wants to
  ///be responsible for. Only requests that contain a macaroon with that specific
  ///custom caveat are then sent to the middleware for inspection. The other
  ///option is to register for the read-only mode in which all requests/responses
  ///are forwarded for interception to the middleware but the middleware is not
  ///allowed to modify any responses. As a security measure, _no_ middleware can
  ///modify responses for requests made with _unencumbered_ macaroons!
  func registerRPCMiddleware(context: StreamingResponseCallContext<Lnrpc_RPCMiddlewareRequest>) -> EventLoopFuture<(StreamEvent<Lnrpc_RPCMiddlewareResponse>) -> Void>

  /// lncli: `sendcustom`
  ///SendCustomMessage sends a custom peer message.
  func sendCustomMessage(request: Lnrpc_SendCustomMessageRequest, context: StatusOnlyCallContext) -> EventLoopFuture<Lnrpc_SendCustomMessageResponse>

  /// lncli: `subscribecustom`
  ///SubscribeCustomMessages subscribes to a stream of incoming custom peer
  ///messages.
  ///
  ///To include messages with type outside of the custom range (>= 32768) lnd
  ///needs to be compiled with  the `dev` build tag, and the message type to
  ///override should be specified in lnd's experimental protocol configuration.
  func subscribeCustomMessages(request: Lnrpc_SubscribeCustomMessagesRequest, context: StreamingResponseCallContext<Lnrpc_CustomMessage>) -> EventLoopFuture<GRPCStatus>

  /// lncli: `listaliases`
  ///ListAliases returns the set of all aliases that have ever existed with
  ///their confirmed SCID (if it exists) and/or the base SCID (in the case of
  ///zero conf).
  func listAliases(request: Lnrpc_ListAliasesRequest, context: StatusOnlyCallContext) -> EventLoopFuture<Lnrpc_ListAliasesResponse>

  ///
  ///LookupHtlcResolution retrieves a final htlc resolution from the database.
  ///If the htlc has no final resolution yet, a NotFound grpc status code is
  ///returned.
  func lookupHtlcResolution(request: Lnrpc_LookupHtlcResolutionRequest, context: StatusOnlyCallContext) -> EventLoopFuture<Lnrpc_LookupHtlcResolutionResponse>
}

extension Lnrpc_LightningProvider {
  internal var serviceName: Substring {
    return Lnrpc_LightningServerMetadata.serviceDescriptor.fullName[...]
  }

  /// Determines, calls and returns the appropriate request handler, depending on the request's method.
  /// Returns nil for methods not handled by this service.
  internal func handle(
    method name: Substring,
    context: CallHandlerContext
  ) -> GRPCServerHandlerProtocol? {
    switch name {
    case "WalletBalance":
      return UnaryServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Lnrpc_WalletBalanceRequest>(),
        responseSerializer: ProtobufSerializer<Lnrpc_WalletBalanceResponse>(),
        interceptors: self.interceptors?.makeWalletBalanceInterceptors() ?? [],
        userFunction: self.walletBalance(request:context:)
      )

    case "ChannelBalance":
      return UnaryServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Lnrpc_ChannelBalanceRequest>(),
        responseSerializer: ProtobufSerializer<Lnrpc_ChannelBalanceResponse>(),
        interceptors: self.interceptors?.makeChannelBalanceInterceptors() ?? [],
        userFunction: self.channelBalance(request:context:)
      )

    case "GetTransactions":
      return UnaryServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Lnrpc_GetTransactionsRequest>(),
        responseSerializer: ProtobufSerializer<Lnrpc_TransactionDetails>(),
        interceptors: self.interceptors?.makeGetTransactionsInterceptors() ?? [],
        userFunction: self.getTransactions(request:context:)
      )

    case "EstimateFee":
      return UnaryServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Lnrpc_EstimateFeeRequest>(),
        responseSerializer: ProtobufSerializer<Lnrpc_EstimateFeeResponse>(),
        interceptors: self.interceptors?.makeEstimateFeeInterceptors() ?? [],
        userFunction: self.estimateFee(request:context:)
      )

    case "SendCoins":
      return UnaryServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Lnrpc_SendCoinsRequest>(),
        responseSerializer: ProtobufSerializer<Lnrpc_SendCoinsResponse>(),
        interceptors: self.interceptors?.makeSendCoinsInterceptors() ?? [],
        userFunction: self.sendCoins(request:context:)
      )

    case "ListUnspent":
      return UnaryServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Lnrpc_ListUnspentRequest>(),
        responseSerializer: ProtobufSerializer<Lnrpc_ListUnspentResponse>(),
        interceptors: self.interceptors?.makeListUnspentInterceptors() ?? [],
        userFunction: self.listUnspent(request:context:)
      )

    case "SubscribeTransactions":
      return ServerStreamingServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Lnrpc_GetTransactionsRequest>(),
        responseSerializer: ProtobufSerializer<Lnrpc_Transaction>(),
        interceptors: self.interceptors?.makeSubscribeTransactionsInterceptors() ?? [],
        userFunction: self.subscribeTransactions(request:context:)
      )

    case "SendMany":
      return UnaryServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Lnrpc_SendManyRequest>(),
        responseSerializer: ProtobufSerializer<Lnrpc_SendManyResponse>(),
        interceptors: self.interceptors?.makeSendManyInterceptors() ?? [],
        userFunction: self.sendMany(request:context:)
      )

    case "NewAddress":
      return UnaryServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Lnrpc_NewAddressRequest>(),
        responseSerializer: ProtobufSerializer<Lnrpc_NewAddressResponse>(),
        interceptors: self.interceptors?.makeNewAddressInterceptors() ?? [],
        userFunction: self.newAddress(request:context:)
      )

    case "SignMessage":
      return UnaryServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Lnrpc_SignMessageRequest>(),
        responseSerializer: ProtobufSerializer<Lnrpc_SignMessageResponse>(),
        interceptors: self.interceptors?.makeSignMessageInterceptors() ?? [],
        userFunction: self.signMessage(request:context:)
      )

    case "VerifyMessage":
      return UnaryServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Lnrpc_VerifyMessageRequest>(),
        responseSerializer: ProtobufSerializer<Lnrpc_VerifyMessageResponse>(),
        interceptors: self.interceptors?.makeVerifyMessageInterceptors() ?? [],
        userFunction: self.verifyMessage(request:context:)
      )

    case "ConnectPeer":
      return UnaryServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Lnrpc_ConnectPeerRequest>(),
        responseSerializer: ProtobufSerializer<Lnrpc_ConnectPeerResponse>(),
        interceptors: self.interceptors?.makeConnectPeerInterceptors() ?? [],
        userFunction: self.connectPeer(request:context:)
      )

    case "DisconnectPeer":
      return UnaryServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Lnrpc_DisconnectPeerRequest>(),
        responseSerializer: ProtobufSerializer<Lnrpc_DisconnectPeerResponse>(),
        interceptors: self.interceptors?.makeDisconnectPeerInterceptors() ?? [],
        userFunction: self.disconnectPeer(request:context:)
      )

    case "ListPeers":
      return UnaryServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Lnrpc_ListPeersRequest>(),
        responseSerializer: ProtobufSerializer<Lnrpc_ListPeersResponse>(),
        interceptors: self.interceptors?.makeListPeersInterceptors() ?? [],
        userFunction: self.listPeers(request:context:)
      )

    case "SubscribePeerEvents":
      return ServerStreamingServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Lnrpc_PeerEventSubscription>(),
        responseSerializer: ProtobufSerializer<Lnrpc_PeerEvent>(),
        interceptors: self.interceptors?.makeSubscribePeerEventsInterceptors() ?? [],
        userFunction: self.subscribePeerEvents(request:context:)
      )

    case "GetInfo":
      return UnaryServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Lnrpc_GetInfoRequest>(),
        responseSerializer: ProtobufSerializer<Lnrpc_GetInfoResponse>(),
        interceptors: self.interceptors?.makeGetInfoInterceptors() ?? [],
        userFunction: self.getInfo(request:context:)
      )

    case "GetRecoveryInfo":
      return UnaryServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Lnrpc_GetRecoveryInfoRequest>(),
        responseSerializer: ProtobufSerializer<Lnrpc_GetRecoveryInfoResponse>(),
        interceptors: self.interceptors?.makeGetRecoveryInfoInterceptors() ?? [],
        userFunction: self.getRecoveryInfo(request:context:)
      )

    case "PendingChannels":
      return UnaryServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Lnrpc_PendingChannelsRequest>(),
        responseSerializer: ProtobufSerializer<Lnrpc_PendingChannelsResponse>(),
        interceptors: self.interceptors?.makePendingChannelsInterceptors() ?? [],
        userFunction: self.pendingChannels(request:context:)
      )

    case "ListChannels":
      return UnaryServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Lnrpc_ListChannelsRequest>(),
        responseSerializer: ProtobufSerializer<Lnrpc_ListChannelsResponse>(),
        interceptors: self.interceptors?.makeListChannelsInterceptors() ?? [],
        userFunction: self.listChannels(request:context:)
      )

    case "SubscribeChannelEvents":
      return ServerStreamingServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Lnrpc_ChannelEventSubscription>(),
        responseSerializer: ProtobufSerializer<Lnrpc_ChannelEventUpdate>(),
        interceptors: self.interceptors?.makeSubscribeChannelEventsInterceptors() ?? [],
        userFunction: self.subscribeChannelEvents(request:context:)
      )

    case "ClosedChannels":
      return UnaryServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Lnrpc_ClosedChannelsRequest>(),
        responseSerializer: ProtobufSerializer<Lnrpc_ClosedChannelsResponse>(),
        interceptors: self.interceptors?.makeClosedChannelsInterceptors() ?? [],
        userFunction: self.closedChannels(request:context:)
      )

    case "OpenChannelSync":
      return UnaryServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Lnrpc_OpenChannelRequest>(),
        responseSerializer: ProtobufSerializer<Lnrpc_ChannelPoint>(),
        interceptors: self.interceptors?.makeOpenChannelSyncInterceptors() ?? [],
        userFunction: self.openChannelSync(request:context:)
      )

    case "OpenChannel":
      return ServerStreamingServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Lnrpc_OpenChannelRequest>(),
        responseSerializer: ProtobufSerializer<Lnrpc_OpenStatusUpdate>(),
        interceptors: self.interceptors?.makeOpenChannelInterceptors() ?? [],
        userFunction: self.openChannel(request:context:)
      )

    case "BatchOpenChannel":
      return UnaryServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Lnrpc_BatchOpenChannelRequest>(),
        responseSerializer: ProtobufSerializer<Lnrpc_BatchOpenChannelResponse>(),
        interceptors: self.interceptors?.makeBatchOpenChannelInterceptors() ?? [],
        userFunction: self.batchOpenChannel(request:context:)
      )

    case "FundingStateStep":
      return UnaryServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Lnrpc_FundingTransitionMsg>(),
        responseSerializer: ProtobufSerializer<Lnrpc_FundingStateStepResp>(),
        interceptors: self.interceptors?.makeFundingStateStepInterceptors() ?? [],
        userFunction: self.fundingStateStep(request:context:)
      )

    case "ChannelAcceptor":
      return BidirectionalStreamingServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Lnrpc_ChannelAcceptResponse>(),
        responseSerializer: ProtobufSerializer<Lnrpc_ChannelAcceptRequest>(),
        interceptors: self.interceptors?.makeChannelAcceptorInterceptors() ?? [],
        observerFactory: self.channelAcceptor(context:)
      )

    case "CloseChannel":
      return ServerStreamingServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Lnrpc_CloseChannelRequest>(),
        responseSerializer: ProtobufSerializer<Lnrpc_CloseStatusUpdate>(),
        interceptors: self.interceptors?.makeCloseChannelInterceptors() ?? [],
        userFunction: self.closeChannel(request:context:)
      )

    case "AbandonChannel":
      return UnaryServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Lnrpc_AbandonChannelRequest>(),
        responseSerializer: ProtobufSerializer<Lnrpc_AbandonChannelResponse>(),
        interceptors: self.interceptors?.makeAbandonChannelInterceptors() ?? [],
        userFunction: self.abandonChannel(request:context:)
      )

    case "SendPayment":
      return BidirectionalStreamingServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Lnrpc_SendRequest>(),
        responseSerializer: ProtobufSerializer<Lnrpc_SendResponse>(),
        interceptors: self.interceptors?.makeSendPaymentInterceptors() ?? [],
        observerFactory: self.sendPayment(context:)
      )

    case "SendPaymentSync":
      return UnaryServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Lnrpc_SendRequest>(),
        responseSerializer: ProtobufSerializer<Lnrpc_SendResponse>(),
        interceptors: self.interceptors?.makeSendPaymentSyncInterceptors() ?? [],
        userFunction: self.sendPaymentSync(request:context:)
      )

    case "SendToRoute":
      return BidirectionalStreamingServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Lnrpc_SendToRouteRequest>(),
        responseSerializer: ProtobufSerializer<Lnrpc_SendResponse>(),
        interceptors: self.interceptors?.makeSendToRouteInterceptors() ?? [],
        observerFactory: self.sendToRoute(context:)
      )

    case "SendToRouteSync":
      return UnaryServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Lnrpc_SendToRouteRequest>(),
        responseSerializer: ProtobufSerializer<Lnrpc_SendResponse>(),
        interceptors: self.interceptors?.makeSendToRouteSyncInterceptors() ?? [],
        userFunction: self.sendToRouteSync(request:context:)
      )

    case "AddInvoice":
      return UnaryServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Lnrpc_Invoice>(),
        responseSerializer: ProtobufSerializer<Lnrpc_AddInvoiceResponse>(),
        interceptors: self.interceptors?.makeAddInvoiceInterceptors() ?? [],
        userFunction: self.addInvoice(request:context:)
      )

    case "ListInvoices":
      return UnaryServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Lnrpc_ListInvoiceRequest>(),
        responseSerializer: ProtobufSerializer<Lnrpc_ListInvoiceResponse>(),
        interceptors: self.interceptors?.makeListInvoicesInterceptors() ?? [],
        userFunction: self.listInvoices(request:context:)
      )

    case "LookupInvoice":
      return UnaryServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Lnrpc_PaymentHash>(),
        responseSerializer: ProtobufSerializer<Lnrpc_Invoice>(),
        interceptors: self.interceptors?.makeLookupInvoiceInterceptors() ?? [],
        userFunction: self.lookupInvoice(request:context:)
      )

    case "SubscribeInvoices":
      return ServerStreamingServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Lnrpc_InvoiceSubscription>(),
        responseSerializer: ProtobufSerializer<Lnrpc_Invoice>(),
        interceptors: self.interceptors?.makeSubscribeInvoicesInterceptors() ?? [],
        userFunction: self.subscribeInvoices(request:context:)
      )

    case "DecodePayReq":
      return UnaryServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Lnrpc_PayReqString>(),
        responseSerializer: ProtobufSerializer<Lnrpc_PayReq>(),
        interceptors: self.interceptors?.makeDecodePayReqInterceptors() ?? [],
        userFunction: self.decodePayReq(request:context:)
      )

    case "ListPayments":
      return UnaryServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Lnrpc_ListPaymentsRequest>(),
        responseSerializer: ProtobufSerializer<Lnrpc_ListPaymentsResponse>(),
        interceptors: self.interceptors?.makeListPaymentsInterceptors() ?? [],
        userFunction: self.listPayments(request:context:)
      )

    case "DeletePayment":
      return UnaryServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Lnrpc_DeletePaymentRequest>(),
        responseSerializer: ProtobufSerializer<Lnrpc_DeletePaymentResponse>(),
        interceptors: self.interceptors?.makeDeletePaymentInterceptors() ?? [],
        userFunction: self.deletePayment(request:context:)
      )

    case "DeleteAllPayments":
      return UnaryServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Lnrpc_DeleteAllPaymentsRequest>(),
        responseSerializer: ProtobufSerializer<Lnrpc_DeleteAllPaymentsResponse>(),
        interceptors: self.interceptors?.makeDeleteAllPaymentsInterceptors() ?? [],
        userFunction: self.deleteAllPayments(request:context:)
      )

    case "DescribeGraph":
      return UnaryServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Lnrpc_ChannelGraphRequest>(),
        responseSerializer: ProtobufSerializer<Lnrpc_ChannelGraph>(),
        interceptors: self.interceptors?.makeDescribeGraphInterceptors() ?? [],
        userFunction: self.describeGraph(request:context:)
      )

    case "GetNodeMetrics":
      return UnaryServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Lnrpc_NodeMetricsRequest>(),
        responseSerializer: ProtobufSerializer<Lnrpc_NodeMetricsResponse>(),
        interceptors: self.interceptors?.makeGetNodeMetricsInterceptors() ?? [],
        userFunction: self.getNodeMetrics(request:context:)
      )

    case "GetChanInfo":
      return UnaryServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Lnrpc_ChanInfoRequest>(),
        responseSerializer: ProtobufSerializer<Lnrpc_ChannelEdge>(),
        interceptors: self.interceptors?.makeGetChanInfoInterceptors() ?? [],
        userFunction: self.getChanInfo(request:context:)
      )

    case "GetNodeInfo":
      return UnaryServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Lnrpc_NodeInfoRequest>(),
        responseSerializer: ProtobufSerializer<Lnrpc_NodeInfo>(),
        interceptors: self.interceptors?.makeGetNodeInfoInterceptors() ?? [],
        userFunction: self.getNodeInfo(request:context:)
      )

    case "QueryRoutes":
      return UnaryServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Lnrpc_QueryRoutesRequest>(),
        responseSerializer: ProtobufSerializer<Lnrpc_QueryRoutesResponse>(),
        interceptors: self.interceptors?.makeQueryRoutesInterceptors() ?? [],
        userFunction: self.queryRoutes(request:context:)
      )

    case "GetNetworkInfo":
      return UnaryServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Lnrpc_NetworkInfoRequest>(),
        responseSerializer: ProtobufSerializer<Lnrpc_NetworkInfo>(),
        interceptors: self.interceptors?.makeGetNetworkInfoInterceptors() ?? [],
        userFunction: self.getNetworkInfo(request:context:)
      )

    case "StopDaemon":
      return UnaryServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Lnrpc_StopRequest>(),
        responseSerializer: ProtobufSerializer<Lnrpc_StopResponse>(),
        interceptors: self.interceptors?.makeStopDaemonInterceptors() ?? [],
        userFunction: self.stopDaemon(request:context:)
      )

    case "SubscribeChannelGraph":
      return ServerStreamingServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Lnrpc_GraphTopologySubscription>(),
        responseSerializer: ProtobufSerializer<Lnrpc_GraphTopologyUpdate>(),
        interceptors: self.interceptors?.makeSubscribeChannelGraphInterceptors() ?? [],
        userFunction: self.subscribeChannelGraph(request:context:)
      )

    case "DebugLevel":
      return UnaryServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Lnrpc_DebugLevelRequest>(),
        responseSerializer: ProtobufSerializer<Lnrpc_DebugLevelResponse>(),
        interceptors: self.interceptors?.makeDebugLevelInterceptors() ?? [],
        userFunction: self.debugLevel(request:context:)
      )

    case "FeeReport":
      return UnaryServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Lnrpc_FeeReportRequest>(),
        responseSerializer: ProtobufSerializer<Lnrpc_FeeReportResponse>(),
        interceptors: self.interceptors?.makeFeeReportInterceptors() ?? [],
        userFunction: self.feeReport(request:context:)
      )

    case "UpdateChannelPolicy":
      return UnaryServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Lnrpc_PolicyUpdateRequest>(),
        responseSerializer: ProtobufSerializer<Lnrpc_PolicyUpdateResponse>(),
        interceptors: self.interceptors?.makeUpdateChannelPolicyInterceptors() ?? [],
        userFunction: self.updateChannelPolicy(request:context:)
      )

    case "ForwardingHistory":
      return UnaryServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Lnrpc_ForwardingHistoryRequest>(),
        responseSerializer: ProtobufSerializer<Lnrpc_ForwardingHistoryResponse>(),
        interceptors: self.interceptors?.makeForwardingHistoryInterceptors() ?? [],
        userFunction: self.forwardingHistory(request:context:)
      )

    case "ExportChannelBackup":
      return UnaryServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Lnrpc_ExportChannelBackupRequest>(),
        responseSerializer: ProtobufSerializer<Lnrpc_ChannelBackup>(),
        interceptors: self.interceptors?.makeExportChannelBackupInterceptors() ?? [],
        userFunction: self.exportChannelBackup(request:context:)
      )

    case "ExportAllChannelBackups":
      return UnaryServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Lnrpc_ChanBackupExportRequest>(),
        responseSerializer: ProtobufSerializer<Lnrpc_ChanBackupSnapshot>(),
        interceptors: self.interceptors?.makeExportAllChannelBackupsInterceptors() ?? [],
        userFunction: self.exportAllChannelBackups(request:context:)
      )

    case "VerifyChanBackup":
      return UnaryServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Lnrpc_ChanBackupSnapshot>(),
        responseSerializer: ProtobufSerializer<Lnrpc_VerifyChanBackupResponse>(),
        interceptors: self.interceptors?.makeVerifyChanBackupInterceptors() ?? [],
        userFunction: self.verifyChanBackup(request:context:)
      )

    case "RestoreChannelBackups":
      return UnaryServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Lnrpc_RestoreChanBackupRequest>(),
        responseSerializer: ProtobufSerializer<Lnrpc_RestoreBackupResponse>(),
        interceptors: self.interceptors?.makeRestoreChannelBackupsInterceptors() ?? [],
        userFunction: self.restoreChannelBackups(request:context:)
      )

    case "SubscribeChannelBackups":
      return ServerStreamingServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Lnrpc_ChannelBackupSubscription>(),
        responseSerializer: ProtobufSerializer<Lnrpc_ChanBackupSnapshot>(),
        interceptors: self.interceptors?.makeSubscribeChannelBackupsInterceptors() ?? [],
        userFunction: self.subscribeChannelBackups(request:context:)
      )

    case "BakeMacaroon":
      return UnaryServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Lnrpc_BakeMacaroonRequest>(),
        responseSerializer: ProtobufSerializer<Lnrpc_BakeMacaroonResponse>(),
        interceptors: self.interceptors?.makeBakeMacaroonInterceptors() ?? [],
        userFunction: self.bakeMacaroon(request:context:)
      )

    case "ListMacaroonIDs":
      return UnaryServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Lnrpc_ListMacaroonIDsRequest>(),
        responseSerializer: ProtobufSerializer<Lnrpc_ListMacaroonIDsResponse>(),
        interceptors: self.interceptors?.makeListMacaroonIDsInterceptors() ?? [],
        userFunction: self.listMacaroonIDs(request:context:)
      )

    case "DeleteMacaroonID":
      return UnaryServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Lnrpc_DeleteMacaroonIDRequest>(),
        responseSerializer: ProtobufSerializer<Lnrpc_DeleteMacaroonIDResponse>(),
        interceptors: self.interceptors?.makeDeleteMacaroonIDInterceptors() ?? [],
        userFunction: self.deleteMacaroonID(request:context:)
      )

    case "ListPermissions":
      return UnaryServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Lnrpc_ListPermissionsRequest>(),
        responseSerializer: ProtobufSerializer<Lnrpc_ListPermissionsResponse>(),
        interceptors: self.interceptors?.makeListPermissionsInterceptors() ?? [],
        userFunction: self.listPermissions(request:context:)
      )

    case "CheckMacaroonPermissions":
      return UnaryServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Lnrpc_CheckMacPermRequest>(),
        responseSerializer: ProtobufSerializer<Lnrpc_CheckMacPermResponse>(),
        interceptors: self.interceptors?.makeCheckMacaroonPermissionsInterceptors() ?? [],
        userFunction: self.checkMacaroonPermissions(request:context:)
      )

    case "RegisterRPCMiddleware":
      return BidirectionalStreamingServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Lnrpc_RPCMiddlewareResponse>(),
        responseSerializer: ProtobufSerializer<Lnrpc_RPCMiddlewareRequest>(),
        interceptors: self.interceptors?.makeRegisterRPCMiddlewareInterceptors() ?? [],
        observerFactory: self.registerRPCMiddleware(context:)
      )

    case "SendCustomMessage":
      return UnaryServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Lnrpc_SendCustomMessageRequest>(),
        responseSerializer: ProtobufSerializer<Lnrpc_SendCustomMessageResponse>(),
        interceptors: self.interceptors?.makeSendCustomMessageInterceptors() ?? [],
        userFunction: self.sendCustomMessage(request:context:)
      )

    case "SubscribeCustomMessages":
      return ServerStreamingServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Lnrpc_SubscribeCustomMessagesRequest>(),
        responseSerializer: ProtobufSerializer<Lnrpc_CustomMessage>(),
        interceptors: self.interceptors?.makeSubscribeCustomMessagesInterceptors() ?? [],
        userFunction: self.subscribeCustomMessages(request:context:)
      )

    case "ListAliases":
      return UnaryServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Lnrpc_ListAliasesRequest>(),
        responseSerializer: ProtobufSerializer<Lnrpc_ListAliasesResponse>(),
        interceptors: self.interceptors?.makeListAliasesInterceptors() ?? [],
        userFunction: self.listAliases(request:context:)
      )

    case "LookupHtlcResolution":
      return UnaryServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Lnrpc_LookupHtlcResolutionRequest>(),
        responseSerializer: ProtobufSerializer<Lnrpc_LookupHtlcResolutionResponse>(),
        interceptors: self.interceptors?.makeLookupHtlcResolutionInterceptors() ?? [],
        userFunction: self.lookupHtlcResolution(request:context:)
      )

    default:
      return nil
    }
  }
}

/// Lightning is the main RPC server of the daemon.
///
/// To implement a server, implement an object which conforms to this protocol.
@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
internal protocol Lnrpc_LightningAsyncProvider: CallHandlerProvider, Sendable {
  static var serviceDescriptor: GRPCServiceDescriptor { get }
  var interceptors: Lnrpc_LightningServerInterceptorFactoryProtocol? { get }

  /// lncli: `walletbalance`
  ///WalletBalance returns total unspent outputs(confirmed and unconfirmed), all
  ///confirmed unspent outputs and all unconfirmed unspent outputs under control
  ///of the wallet.
  func walletBalance(
    request: Lnrpc_WalletBalanceRequest,
    context: GRPCAsyncServerCallContext
  ) async throws -> Lnrpc_WalletBalanceResponse

  /// lncli: `channelbalance`
  ///ChannelBalance returns a report on the total funds across all open channels,
  ///categorized in local/remote, pending local/remote and unsettled local/remote
  ///balances.
  func channelBalance(
    request: Lnrpc_ChannelBalanceRequest,
    context: GRPCAsyncServerCallContext
  ) async throws -> Lnrpc_ChannelBalanceResponse

  /// lncli: `listchaintxns`
  ///GetTransactions returns a list describing all the known transactions
  ///relevant to the wallet.
  func getTransactions(
    request: Lnrpc_GetTransactionsRequest,
    context: GRPCAsyncServerCallContext
  ) async throws -> Lnrpc_TransactionDetails

  /// lncli: `estimatefee`
  ///EstimateFee asks the chain backend to estimate the fee rate and total fees
  ///for a transaction that pays to multiple specified outputs.
  ///
  ///When using REST, the `AddrToAmount` map type can be set by appending
  ///`&AddrToAmount[<address>]=<amount_to_send>` to the URL. Unfortunately this
  ///map type doesn't appear in the REST API documentation because of a bug in
  ///the grpc-gateway library.
  func estimateFee(
    request: Lnrpc_EstimateFeeRequest,
    context: GRPCAsyncServerCallContext
  ) async throws -> Lnrpc_EstimateFeeResponse

  /// lncli: `sendcoins`
  ///SendCoins executes a request to send coins to a particular address. Unlike
  ///SendMany, this RPC call only allows creating a single output at a time. If
  ///neither target_conf, or sat_per_vbyte are set, then the internal wallet will
  ///consult its fee model to determine a fee for the default confirmation
  ///target.
  func sendCoins(
    request: Lnrpc_SendCoinsRequest,
    context: GRPCAsyncServerCallContext
  ) async throws -> Lnrpc_SendCoinsResponse

  /// lncli: `listunspent`
  ///Deprecated, use walletrpc.ListUnspent instead.
  ///
  ///ListUnspent returns a list of all utxos spendable by the wallet with a
  ///number of confirmations between the specified minimum and maximum.
  func listUnspent(
    request: Lnrpc_ListUnspentRequest,
    context: GRPCAsyncServerCallContext
  ) async throws -> Lnrpc_ListUnspentResponse

  ///
  ///SubscribeTransactions creates a uni-directional stream from the server to
  ///the client in which any newly discovered transactions relevant to the
  ///wallet are sent over.
  func subscribeTransactions(
    request: Lnrpc_GetTransactionsRequest,
    responseStream: GRPCAsyncResponseStreamWriter<Lnrpc_Transaction>,
    context: GRPCAsyncServerCallContext
  ) async throws

  /// lncli: `sendmany`
  ///SendMany handles a request for a transaction that creates multiple specified
  ///outputs in parallel. If neither target_conf, or sat_per_vbyte are set, then
  ///the internal wallet will consult its fee model to determine a fee for the
  ///default confirmation target.
  func sendMany(
    request: Lnrpc_SendManyRequest,
    context: GRPCAsyncServerCallContext
  ) async throws -> Lnrpc_SendManyResponse

  /// lncli: `newaddress`
  ///NewAddress creates a new address under control of the local wallet.
  func newAddress(
    request: Lnrpc_NewAddressRequest,
    context: GRPCAsyncServerCallContext
  ) async throws -> Lnrpc_NewAddressResponse

  /// lncli: `signmessage`
  ///SignMessage signs a message with this node's private key. The returned
  ///signature string is `zbase32` encoded and pubkey recoverable, meaning that
  ///only the message digest and signature are needed for verification.
  func signMessage(
    request: Lnrpc_SignMessageRequest,
    context: GRPCAsyncServerCallContext
  ) async throws -> Lnrpc_SignMessageResponse

  /// lncli: `verifymessage`
  ///VerifyMessage verifies a signature over a message and recovers the signer's
  ///public key. The signature is only deemed valid if the recovered public key
  ///corresponds to a node key in the public Lightning network. The signature
  ///must be zbase32 encoded and signed by an active node in the resident node's
  ///channel database. In addition to returning the validity of the signature,
  ///VerifyMessage also returns the recovered pubkey from the signature.
  func verifyMessage(
    request: Lnrpc_VerifyMessageRequest,
    context: GRPCAsyncServerCallContext
  ) async throws -> Lnrpc_VerifyMessageResponse

  /// lncli: `connect`
  ///ConnectPeer attempts to establish a connection to a remote peer. This is at
  ///the networking level, and is used for communication between nodes. This is
  ///distinct from establishing a channel with a peer.
  func connectPeer(
    request: Lnrpc_ConnectPeerRequest,
    context: GRPCAsyncServerCallContext
  ) async throws -> Lnrpc_ConnectPeerResponse

  /// lncli: `disconnect`
  ///DisconnectPeer attempts to disconnect one peer from another identified by a
  ///given pubKey. In the case that we currently have a pending or active channel
  ///with the target peer, then this action will be not be allowed.
  func disconnectPeer(
    request: Lnrpc_DisconnectPeerRequest,
    context: GRPCAsyncServerCallContext
  ) async throws -> Lnrpc_DisconnectPeerResponse

  /// lncli: `listpeers`
  ///ListPeers returns a verbose listing of all currently active peers.
  func listPeers(
    request: Lnrpc_ListPeersRequest,
    context: GRPCAsyncServerCallContext
  ) async throws -> Lnrpc_ListPeersResponse

  ///
  ///SubscribePeerEvents creates a uni-directional stream from the server to
  ///the client in which any events relevant to the state of peers are sent
  ///over. Events include peers going online and offline.
  func subscribePeerEvents(
    request: Lnrpc_PeerEventSubscription,
    responseStream: GRPCAsyncResponseStreamWriter<Lnrpc_PeerEvent>,
    context: GRPCAsyncServerCallContext
  ) async throws

  /// lncli: `getinfo`
  ///GetInfo returns general information concerning the lightning node including
  ///it's identity pubkey, alias, the chains it is connected to, and information
  ///concerning the number of open+pending channels.
  func getInfo(
    request: Lnrpc_GetInfoRequest,
    context: GRPCAsyncServerCallContext
  ) async throws -> Lnrpc_GetInfoResponse

  ///* lncli: `getrecoveryinfo`
  ///GetRecoveryInfo returns information concerning the recovery mode including
  ///whether it's in a recovery mode, whether the recovery is finished, and the
  ///progress made so far.
  func getRecoveryInfo(
    request: Lnrpc_GetRecoveryInfoRequest,
    context: GRPCAsyncServerCallContext
  ) async throws -> Lnrpc_GetRecoveryInfoResponse

  /// lncli: `pendingchannels`
  ///PendingChannels returns a list of all the channels that are currently
  ///considered "pending". A channel is pending if it has finished the funding
  ///workflow and is waiting for confirmations for the funding txn, or is in the
  ///process of closure, either initiated cooperatively or non-cooperatively.
  func pendingChannels(
    request: Lnrpc_PendingChannelsRequest,
    context: GRPCAsyncServerCallContext
  ) async throws -> Lnrpc_PendingChannelsResponse

  /// lncli: `listchannels`
  ///ListChannels returns a description of all the open channels that this node
  ///is a participant in.
  func listChannels(
    request: Lnrpc_ListChannelsRequest,
    context: GRPCAsyncServerCallContext
  ) async throws -> Lnrpc_ListChannelsResponse

  ///
  ///SubscribeChannelEvents creates a uni-directional stream from the server to
  ///the client in which any updates relevant to the state of the channels are
  ///sent over. Events include new active channels, inactive channels, and closed
  ///channels.
  func subscribeChannelEvents(
    request: Lnrpc_ChannelEventSubscription,
    responseStream: GRPCAsyncResponseStreamWriter<Lnrpc_ChannelEventUpdate>,
    context: GRPCAsyncServerCallContext
  ) async throws

  /// lncli: `closedchannels`
  ///ClosedChannels returns a description of all the closed channels that
  ///this node was a participant in.
  func closedChannels(
    request: Lnrpc_ClosedChannelsRequest,
    context: GRPCAsyncServerCallContext
  ) async throws -> Lnrpc_ClosedChannelsResponse

  ///
  ///OpenChannelSync is a synchronous version of the OpenChannel RPC call. This
  ///call is meant to be consumed by clients to the REST proxy. As with all
  ///other sync calls, all byte slices are intended to be populated as hex
  ///encoded strings.
  func openChannelSync(
    request: Lnrpc_OpenChannelRequest,
    context: GRPCAsyncServerCallContext
  ) async throws -> Lnrpc_ChannelPoint

  /// lncli: `openchannel`
  ///OpenChannel attempts to open a singly funded channel specified in the
  ///request to a remote peer. Users are able to specify a target number of
  ///blocks that the funding transaction should be confirmed in, or a manual fee
  ///rate to us for the funding transaction. If neither are specified, then a
  ///lax block confirmation target is used. Each OpenStatusUpdate will return
  ///the pending channel ID of the in-progress channel. Depending on the
  ///arguments specified in the OpenChannelRequest, this pending channel ID can
  ///then be used to manually progress the channel funding flow.
  func openChannel(
    request: Lnrpc_OpenChannelRequest,
    responseStream: GRPCAsyncResponseStreamWriter<Lnrpc_OpenStatusUpdate>,
    context: GRPCAsyncServerCallContext
  ) async throws

  /// lncli: `batchopenchannel`
  ///BatchOpenChannel attempts to open multiple single-funded channels in a
  ///single transaction in an atomic way. This means either all channel open
  ///requests succeed at once or all attempts are aborted if any of them fail.
  ///This is the safer variant of using PSBTs to manually fund a batch of
  ///channels through the OpenChannel RPC.
  func batchOpenChannel(
    request: Lnrpc_BatchOpenChannelRequest,
    context: GRPCAsyncServerCallContext
  ) async throws -> Lnrpc_BatchOpenChannelResponse

  ///
  ///FundingStateStep is an advanced funding related call that allows the caller
  ///to either execute some preparatory steps for a funding workflow, or
  ///manually progress a funding workflow. The primary way a funding flow is
  ///identified is via its pending channel ID. As an example, this method can be
  ///used to specify that we're expecting a funding flow for a particular
  ///pending channel ID, for which we need to use specific parameters.
  ///Alternatively, this can be used to interactively drive PSBT signing for
  ///funding for partially complete funding transactions.
  func fundingStateStep(
    request: Lnrpc_FundingTransitionMsg,
    context: GRPCAsyncServerCallContext
  ) async throws -> Lnrpc_FundingStateStepResp

  ///
  ///ChannelAcceptor dispatches a bi-directional streaming RPC in which
  ///OpenChannel requests are sent to the client and the client responds with
  ///a boolean that tells LND whether or not to accept the channel. This allows
  ///node operators to specify their own criteria for accepting inbound channels
  ///through a single persistent connection.
  func channelAcceptor(
    requestStream: GRPCAsyncRequestStream<Lnrpc_ChannelAcceptResponse>,
    responseStream: GRPCAsyncResponseStreamWriter<Lnrpc_ChannelAcceptRequest>,
    context: GRPCAsyncServerCallContext
  ) async throws

  /// lncli: `closechannel`
  ///CloseChannel attempts to close an active channel identified by its channel
  ///outpoint (ChannelPoint). The actions of this method can additionally be
  ///augmented to attempt a force close after a timeout period in the case of an
  ///inactive peer. If a non-force close (cooperative closure) is requested,
  ///then the user can specify either a target number of blocks until the
  ///closure transaction is confirmed, or a manual fee rate. If neither are
  ///specified, then a default lax, block confirmation target is used.
  func closeChannel(
    request: Lnrpc_CloseChannelRequest,
    responseStream: GRPCAsyncResponseStreamWriter<Lnrpc_CloseStatusUpdate>,
    context: GRPCAsyncServerCallContext
  ) async throws

  /// lncli: `abandonchannel`
  ///AbandonChannel removes all channel state from the database except for a
  ///close summary. This method can be used to get rid of permanently unusable
  ///channels due to bugs fixed in newer versions of lnd. This method can also be
  ///used to remove externally funded channels where the funding transaction was
  ///never broadcast. Only available for non-externally funded channels in dev
  ///build.
  func abandonChannel(
    request: Lnrpc_AbandonChannelRequest,
    context: GRPCAsyncServerCallContext
  ) async throws -> Lnrpc_AbandonChannelResponse

  /// lncli: `sendpayment`
  ///Deprecated, use routerrpc.SendPaymentV2. SendPayment dispatches a
  ///bi-directional streaming RPC for sending payments through the Lightning
  ///Network. A single RPC invocation creates a persistent bi-directional
  ///stream allowing clients to rapidly send payments through the Lightning
  ///Network with a single persistent connection.
  func sendPayment(
    requestStream: GRPCAsyncRequestStream<Lnrpc_SendRequest>,
    responseStream: GRPCAsyncResponseStreamWriter<Lnrpc_SendResponse>,
    context: GRPCAsyncServerCallContext
  ) async throws

  ///
  ///SendPaymentSync is the synchronous non-streaming version of SendPayment.
  ///This RPC is intended to be consumed by clients of the REST proxy.
  ///Additionally, this RPC expects the destination's public key and the payment
  ///hash (if any) to be encoded as hex strings.
  func sendPaymentSync(
    request: Lnrpc_SendRequest,
    context: GRPCAsyncServerCallContext
  ) async throws -> Lnrpc_SendResponse

  /// lncli: `sendtoroute`
  ///Deprecated, use routerrpc.SendToRouteV2. SendToRoute is a bi-directional
  ///streaming RPC for sending payment through the Lightning Network. This
  ///method differs from SendPayment in that it allows users to specify a full
  ///route manually. This can be used for things like rebalancing, and atomic
  ///swaps.
  func sendToRoute(
    requestStream: GRPCAsyncRequestStream<Lnrpc_SendToRouteRequest>,
    responseStream: GRPCAsyncResponseStreamWriter<Lnrpc_SendResponse>,
    context: GRPCAsyncServerCallContext
  ) async throws

  ///
  ///SendToRouteSync is a synchronous version of SendToRoute. It Will block
  ///until the payment either fails or succeeds.
  func sendToRouteSync(
    request: Lnrpc_SendToRouteRequest,
    context: GRPCAsyncServerCallContext
  ) async throws -> Lnrpc_SendResponse

  /// lncli: `addinvoice`
  ///AddInvoice attempts to add a new invoice to the invoice database. Any
  ///duplicated invoices are rejected, therefore all invoices *must* have a
  ///unique payment preimage.
  func addInvoice(
    request: Lnrpc_Invoice,
    context: GRPCAsyncServerCallContext
  ) async throws -> Lnrpc_AddInvoiceResponse

  /// lncli: `listinvoices`
  ///ListInvoices returns a list of all the invoices currently stored within the
  ///database. Any active debug invoices are ignored. It has full support for
  ///paginated responses, allowing users to query for specific invoices through
  ///their add_index. This can be done by using either the first_index_offset or
  ///last_index_offset fields included in the response as the index_offset of the
  ///next request. By default, the first 100 invoices created will be returned.
  ///Backwards pagination is also supported through the Reversed flag.
  func listInvoices(
    request: Lnrpc_ListInvoiceRequest,
    context: GRPCAsyncServerCallContext
  ) async throws -> Lnrpc_ListInvoiceResponse

  /// lncli: `lookupinvoice`
  ///LookupInvoice attempts to look up an invoice according to its payment hash.
  ///The passed payment hash *must* be exactly 32 bytes, if not, an error is
  ///returned.
  func lookupInvoice(
    request: Lnrpc_PaymentHash,
    context: GRPCAsyncServerCallContext
  ) async throws -> Lnrpc_Invoice

  ///
  ///SubscribeInvoices returns a uni-directional stream (server -> client) for
  ///notifying the client of newly added/settled invoices. The caller can
  ///optionally specify the add_index and/or the settle_index. If the add_index
  ///is specified, then we'll first start by sending add invoice events for all
  ///invoices with an add_index greater than the specified value. If the
  ///settle_index is specified, the next, we'll send out all settle events for
  ///invoices with a settle_index greater than the specified value. One or both
  ///of these fields can be set. If no fields are set, then we'll only send out
  ///the latest add/settle events.
  func subscribeInvoices(
    request: Lnrpc_InvoiceSubscription,
    responseStream: GRPCAsyncResponseStreamWriter<Lnrpc_Invoice>,
    context: GRPCAsyncServerCallContext
  ) async throws

  /// lncli: `decodepayreq`
  ///DecodePayReq takes an encoded payment request string and attempts to decode
  ///it, returning a full description of the conditions encoded within the
  ///payment request.
  func decodePayReq(
    request: Lnrpc_PayReqString,
    context: GRPCAsyncServerCallContext
  ) async throws -> Lnrpc_PayReq

  /// lncli: `listpayments`
  ///ListPayments returns a list of all outgoing payments.
  func listPayments(
    request: Lnrpc_ListPaymentsRequest,
    context: GRPCAsyncServerCallContext
  ) async throws -> Lnrpc_ListPaymentsResponse

  ///
  ///DeletePayment deletes an outgoing payment from DB. Note that it will not
  ///attempt to delete an In-Flight payment, since that would be unsafe.
  func deletePayment(
    request: Lnrpc_DeletePaymentRequest,
    context: GRPCAsyncServerCallContext
  ) async throws -> Lnrpc_DeletePaymentResponse

  ///
  ///DeleteAllPayments deletes all outgoing payments from DB. Note that it will
  ///not attempt to delete In-Flight payments, since that would be unsafe.
  func deleteAllPayments(
    request: Lnrpc_DeleteAllPaymentsRequest,
    context: GRPCAsyncServerCallContext
  ) async throws -> Lnrpc_DeleteAllPaymentsResponse

  /// lncli: `describegraph`
  ///DescribeGraph returns a description of the latest graph state from the
  ///point of view of the node. The graph information is partitioned into two
  ///components: all the nodes/vertexes, and all the edges that connect the
  ///vertexes themselves. As this is a directed graph, the edges also contain
  ///the node directional specific routing policy which includes: the time lock
  ///delta, fee information, etc.
  func describeGraph(
    request: Lnrpc_ChannelGraphRequest,
    context: GRPCAsyncServerCallContext
  ) async throws -> Lnrpc_ChannelGraph

  /// lncli: `getnodemetrics`
  ///GetNodeMetrics returns node metrics calculated from the graph. Currently
  ///the only supported metric is betweenness centrality of individual nodes.
  func getNodeMetrics(
    request: Lnrpc_NodeMetricsRequest,
    context: GRPCAsyncServerCallContext
  ) async throws -> Lnrpc_NodeMetricsResponse

  /// lncli: `getchaninfo`
  ///GetChanInfo returns the latest authenticated network announcement for the
  ///given channel identified by its channel ID: an 8-byte integer which
  ///uniquely identifies the location of transaction's funding output within the
  ///blockchain.
  func getChanInfo(
    request: Lnrpc_ChanInfoRequest,
    context: GRPCAsyncServerCallContext
  ) async throws -> Lnrpc_ChannelEdge

  /// lncli: `getnodeinfo`
  ///GetNodeInfo returns the latest advertised, aggregated, and authenticated
  ///channel information for the specified node identified by its public key.
  func getNodeInfo(
    request: Lnrpc_NodeInfoRequest,
    context: GRPCAsyncServerCallContext
  ) async throws -> Lnrpc_NodeInfo

  /// lncli: `queryroutes`
  ///QueryRoutes attempts to query the daemon's Channel Router for a possible
  ///route to a target destination capable of carrying a specific amount of
  ///satoshis. The returned route contains the full details required to craft and
  ///send an HTLC, also including the necessary information that should be
  ///present within the Sphinx packet encapsulated within the HTLC.
  ///
  ///When using REST, the `dest_custom_records` map type can be set by appending
  ///`&dest_custom_records[<record_number>]=<record_data_base64_url_encoded>`
  ///to the URL. Unfortunately this map type doesn't appear in the REST API
  ///documentation because of a bug in the grpc-gateway library.
  func queryRoutes(
    request: Lnrpc_QueryRoutesRequest,
    context: GRPCAsyncServerCallContext
  ) async throws -> Lnrpc_QueryRoutesResponse

  /// lncli: `getnetworkinfo`
  ///GetNetworkInfo returns some basic stats about the known channel graph from
  ///the point of view of the node.
  func getNetworkInfo(
    request: Lnrpc_NetworkInfoRequest,
    context: GRPCAsyncServerCallContext
  ) async throws -> Lnrpc_NetworkInfo

  /// lncli: `stop`
  ///StopDaemon will send a shutdown request to the interrupt handler, triggering
  ///a graceful shutdown of the daemon.
  func stopDaemon(
    request: Lnrpc_StopRequest,
    context: GRPCAsyncServerCallContext
  ) async throws -> Lnrpc_StopResponse

  ///
  ///SubscribeChannelGraph launches a streaming RPC that allows the caller to
  ///receive notifications upon any changes to the channel graph topology from
  ///the point of view of the responding node. Events notified include: new
  ///nodes coming online, nodes updating their authenticated attributes, new
  ///channels being advertised, updates in the routing policy for a directional
  ///channel edge, and when channels are closed on-chain.
  func subscribeChannelGraph(
    request: Lnrpc_GraphTopologySubscription,
    responseStream: GRPCAsyncResponseStreamWriter<Lnrpc_GraphTopologyUpdate>,
    context: GRPCAsyncServerCallContext
  ) async throws

  /// lncli: `debuglevel`
  ///DebugLevel allows a caller to programmatically set the logging verbosity of
  ///lnd. The logging can be targeted according to a coarse daemon-wide logging
  ///level, or in a granular fashion to specify the logging for a target
  ///sub-system.
  func debugLevel(
    request: Lnrpc_DebugLevelRequest,
    context: GRPCAsyncServerCallContext
  ) async throws -> Lnrpc_DebugLevelResponse

  /// lncli: `feereport`
  ///FeeReport allows the caller to obtain a report detailing the current fee
  ///schedule enforced by the node globally for each channel.
  func feeReport(
    request: Lnrpc_FeeReportRequest,
    context: GRPCAsyncServerCallContext
  ) async throws -> Lnrpc_FeeReportResponse

  /// lncli: `updatechanpolicy`
  ///UpdateChannelPolicy allows the caller to update the fee schedule and
  ///channel policies for all channels globally, or a particular channel.
  func updateChannelPolicy(
    request: Lnrpc_PolicyUpdateRequest,
    context: GRPCAsyncServerCallContext
  ) async throws -> Lnrpc_PolicyUpdateResponse

  /// lncli: `fwdinghistory`
  ///ForwardingHistory allows the caller to query the htlcswitch for a record of
  ///all HTLCs forwarded within the target time range, and integer offset
  ///within that time range, for a maximum number of events. If no maximum number
  ///of events is specified, up to 100 events will be returned. If no time-range
  ///is specified, then events will be returned in the order that they occured.
  ///
  ///A list of forwarding events are returned. The size of each forwarding event
  ///is 40 bytes, and the max message size able to be returned in gRPC is 4 MiB.
  ///As a result each message can only contain 50k entries. Each response has
  ///the index offset of the last entry. The index offset can be provided to the
  ///request to allow the caller to skip a series of records.
  func forwardingHistory(
    request: Lnrpc_ForwardingHistoryRequest,
    context: GRPCAsyncServerCallContext
  ) async throws -> Lnrpc_ForwardingHistoryResponse

  /// lncli: `exportchanbackup`
  ///ExportChannelBackup attempts to return an encrypted static channel backup
  ///for the target channel identified by it channel point. The backup is
  ///encrypted with a key generated from the aezeed seed of the user. The
  ///returned backup can either be restored using the RestoreChannelBackup
  ///method once lnd is running, or via the InitWallet and UnlockWallet methods
  ///from the WalletUnlocker service.
  func exportChannelBackup(
    request: Lnrpc_ExportChannelBackupRequest,
    context: GRPCAsyncServerCallContext
  ) async throws -> Lnrpc_ChannelBackup

  ///
  ///ExportAllChannelBackups returns static channel backups for all existing
  ///channels known to lnd. A set of regular singular static channel backups for
  ///each channel are returned. Additionally, a multi-channel backup is returned
  ///as well, which contains a single encrypted blob containing the backups of
  ///each channel.
  func exportAllChannelBackups(
    request: Lnrpc_ChanBackupExportRequest,
    context: GRPCAsyncServerCallContext
  ) async throws -> Lnrpc_ChanBackupSnapshot

  ///
  ///VerifyChanBackup allows a caller to verify the integrity of a channel backup
  ///snapshot. This method will accept either a packed Single or a packed Multi.
  ///Specifying both will result in an error.
  func verifyChanBackup(
    request: Lnrpc_ChanBackupSnapshot,
    context: GRPCAsyncServerCallContext
  ) async throws -> Lnrpc_VerifyChanBackupResponse

  /// lncli: `restorechanbackup`
  ///RestoreChannelBackups accepts a set of singular channel backups, or a
  ///single encrypted multi-chan backup and attempts to recover any funds
  ///remaining within the channel. If we are able to unpack the backup, then the
  ///new channel will be shown under listchannels, as well as pending channels.
  func restoreChannelBackups(
    request: Lnrpc_RestoreChanBackupRequest,
    context: GRPCAsyncServerCallContext
  ) async throws -> Lnrpc_RestoreBackupResponse

  ///
  ///SubscribeChannelBackups allows a client to sub-subscribe to the most up to
  ///date information concerning the state of all channel backups. Each time a
  ///new channel is added, we return the new set of channels, along with a
  ///multi-chan backup containing the backup info for all channels. Each time a
  ///channel is closed, we send a new update, which contains new new chan back
  ///ups, but the updated set of encrypted multi-chan backups with the closed
  ///channel(s) removed.
  func subscribeChannelBackups(
    request: Lnrpc_ChannelBackupSubscription,
    responseStream: GRPCAsyncResponseStreamWriter<Lnrpc_ChanBackupSnapshot>,
    context: GRPCAsyncServerCallContext
  ) async throws

  /// lncli: `bakemacaroon`
  ///BakeMacaroon allows the creation of a new macaroon with custom read and
  ///write permissions. No first-party caveats are added since this can be done
  ///offline.
  func bakeMacaroon(
    request: Lnrpc_BakeMacaroonRequest,
    context: GRPCAsyncServerCallContext
  ) async throws -> Lnrpc_BakeMacaroonResponse

  /// lncli: `listmacaroonids`
  ///ListMacaroonIDs returns all root key IDs that are in use.
  func listMacaroonIDs(
    request: Lnrpc_ListMacaroonIDsRequest,
    context: GRPCAsyncServerCallContext
  ) async throws -> Lnrpc_ListMacaroonIDsResponse

  /// lncli: `deletemacaroonid`
  ///DeleteMacaroonID deletes the specified macaroon ID and invalidates all
  ///macaroons derived from that ID.
  func deleteMacaroonID(
    request: Lnrpc_DeleteMacaroonIDRequest,
    context: GRPCAsyncServerCallContext
  ) async throws -> Lnrpc_DeleteMacaroonIDResponse

  /// lncli: `listpermissions`
  ///ListPermissions lists all RPC method URIs and their required macaroon
  ///permissions to access them.
  func listPermissions(
    request: Lnrpc_ListPermissionsRequest,
    context: GRPCAsyncServerCallContext
  ) async throws -> Lnrpc_ListPermissionsResponse

  ///
  ///CheckMacaroonPermissions checks whether a request follows the constraints
  ///imposed on the macaroon and that the macaroon is authorized to follow the
  ///provided permissions.
  func checkMacaroonPermissions(
    request: Lnrpc_CheckMacPermRequest,
    context: GRPCAsyncServerCallContext
  ) async throws -> Lnrpc_CheckMacPermResponse

  ///
  ///RegisterRPCMiddleware adds a new gRPC middleware to the interceptor chain. A
  ///gRPC middleware is software component external to lnd that aims to add
  ///additional business logic to lnd by observing/intercepting/validating
  ///incoming gRPC client requests and (if needed) replacing/overwriting outgoing
  ///messages before they're sent to the client. When registering the middleware
  ///must identify itself and indicate what custom macaroon caveats it wants to
  ///be responsible for. Only requests that contain a macaroon with that specific
  ///custom caveat are then sent to the middleware for inspection. The other
  ///option is to register for the read-only mode in which all requests/responses
  ///are forwarded for interception to the middleware but the middleware is not
  ///allowed to modify any responses. As a security measure, _no_ middleware can
  ///modify responses for requests made with _unencumbered_ macaroons!
  func registerRPCMiddleware(
    requestStream: GRPCAsyncRequestStream<Lnrpc_RPCMiddlewareResponse>,
    responseStream: GRPCAsyncResponseStreamWriter<Lnrpc_RPCMiddlewareRequest>,
    context: GRPCAsyncServerCallContext
  ) async throws

  /// lncli: `sendcustom`
  ///SendCustomMessage sends a custom peer message.
  func sendCustomMessage(
    request: Lnrpc_SendCustomMessageRequest,
    context: GRPCAsyncServerCallContext
  ) async throws -> Lnrpc_SendCustomMessageResponse

  /// lncli: `subscribecustom`
  ///SubscribeCustomMessages subscribes to a stream of incoming custom peer
  ///messages.
  ///
  ///To include messages with type outside of the custom range (>= 32768) lnd
  ///needs to be compiled with  the `dev` build tag, and the message type to
  ///override should be specified in lnd's experimental protocol configuration.
  func subscribeCustomMessages(
    request: Lnrpc_SubscribeCustomMessagesRequest,
    responseStream: GRPCAsyncResponseStreamWriter<Lnrpc_CustomMessage>,
    context: GRPCAsyncServerCallContext
  ) async throws

  /// lncli: `listaliases`
  ///ListAliases returns the set of all aliases that have ever existed with
  ///their confirmed SCID (if it exists) and/or the base SCID (in the case of
  ///zero conf).
  func listAliases(
    request: Lnrpc_ListAliasesRequest,
    context: GRPCAsyncServerCallContext
  ) async throws -> Lnrpc_ListAliasesResponse

  ///
  ///LookupHtlcResolution retrieves a final htlc resolution from the database.
  ///If the htlc has no final resolution yet, a NotFound grpc status code is
  ///returned.
  func lookupHtlcResolution(
    request: Lnrpc_LookupHtlcResolutionRequest,
    context: GRPCAsyncServerCallContext
  ) async throws -> Lnrpc_LookupHtlcResolutionResponse
}

@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
extension Lnrpc_LightningAsyncProvider {
  internal static var serviceDescriptor: GRPCServiceDescriptor {
    return Lnrpc_LightningServerMetadata.serviceDescriptor
  }

  internal var serviceName: Substring {
    return Lnrpc_LightningServerMetadata.serviceDescriptor.fullName[...]
  }

  internal var interceptors: Lnrpc_LightningServerInterceptorFactoryProtocol? {
    return nil
  }

  internal func handle(
    method name: Substring,
    context: CallHandlerContext
  ) -> GRPCServerHandlerProtocol? {
    switch name {
    case "WalletBalance":
      return GRPCAsyncServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Lnrpc_WalletBalanceRequest>(),
        responseSerializer: ProtobufSerializer<Lnrpc_WalletBalanceResponse>(),
        interceptors: self.interceptors?.makeWalletBalanceInterceptors() ?? [],
        wrapping: { try await self.walletBalance(request: $0, context: $1) }
      )

    case "ChannelBalance":
      return GRPCAsyncServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Lnrpc_ChannelBalanceRequest>(),
        responseSerializer: ProtobufSerializer<Lnrpc_ChannelBalanceResponse>(),
        interceptors: self.interceptors?.makeChannelBalanceInterceptors() ?? [],
        wrapping: { try await self.channelBalance(request: $0, context: $1) }
      )

    case "GetTransactions":
      return GRPCAsyncServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Lnrpc_GetTransactionsRequest>(),
        responseSerializer: ProtobufSerializer<Lnrpc_TransactionDetails>(),
        interceptors: self.interceptors?.makeGetTransactionsInterceptors() ?? [],
        wrapping: { try await self.getTransactions(request: $0, context: $1) }
      )

    case "EstimateFee":
      return GRPCAsyncServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Lnrpc_EstimateFeeRequest>(),
        responseSerializer: ProtobufSerializer<Lnrpc_EstimateFeeResponse>(),
        interceptors: self.interceptors?.makeEstimateFeeInterceptors() ?? [],
        wrapping: { try await self.estimateFee(request: $0, context: $1) }
      )

    case "SendCoins":
      return GRPCAsyncServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Lnrpc_SendCoinsRequest>(),
        responseSerializer: ProtobufSerializer<Lnrpc_SendCoinsResponse>(),
        interceptors: self.interceptors?.makeSendCoinsInterceptors() ?? [],
        wrapping: { try await self.sendCoins(request: $0, context: $1) }
      )

    case "ListUnspent":
      return GRPCAsyncServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Lnrpc_ListUnspentRequest>(),
        responseSerializer: ProtobufSerializer<Lnrpc_ListUnspentResponse>(),
        interceptors: self.interceptors?.makeListUnspentInterceptors() ?? [],
        wrapping: { try await self.listUnspent(request: $0, context: $1) }
      )

    case "SubscribeTransactions":
      return GRPCAsyncServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Lnrpc_GetTransactionsRequest>(),
        responseSerializer: ProtobufSerializer<Lnrpc_Transaction>(),
        interceptors: self.interceptors?.makeSubscribeTransactionsInterceptors() ?? [],
        wrapping: { try await self.subscribeTransactions(request: $0, responseStream: $1, context: $2) }
      )

    case "SendMany":
      return GRPCAsyncServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Lnrpc_SendManyRequest>(),
        responseSerializer: ProtobufSerializer<Lnrpc_SendManyResponse>(),
        interceptors: self.interceptors?.makeSendManyInterceptors() ?? [],
        wrapping: { try await self.sendMany(request: $0, context: $1) }
      )

    case "NewAddress":
      return GRPCAsyncServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Lnrpc_NewAddressRequest>(),
        responseSerializer: ProtobufSerializer<Lnrpc_NewAddressResponse>(),
        interceptors: self.interceptors?.makeNewAddressInterceptors() ?? [],
        wrapping: { try await self.newAddress(request: $0, context: $1) }
      )

    case "SignMessage":
      return GRPCAsyncServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Lnrpc_SignMessageRequest>(),
        responseSerializer: ProtobufSerializer<Lnrpc_SignMessageResponse>(),
        interceptors: self.interceptors?.makeSignMessageInterceptors() ?? [],
        wrapping: { try await self.signMessage(request: $0, context: $1) }
      )

    case "VerifyMessage":
      return GRPCAsyncServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Lnrpc_VerifyMessageRequest>(),
        responseSerializer: ProtobufSerializer<Lnrpc_VerifyMessageResponse>(),
        interceptors: self.interceptors?.makeVerifyMessageInterceptors() ?? [],
        wrapping: { try await self.verifyMessage(request: $0, context: $1) }
      )

    case "ConnectPeer":
      return GRPCAsyncServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Lnrpc_ConnectPeerRequest>(),
        responseSerializer: ProtobufSerializer<Lnrpc_ConnectPeerResponse>(),
        interceptors: self.interceptors?.makeConnectPeerInterceptors() ?? [],
        wrapping: { try await self.connectPeer(request: $0, context: $1) }
      )

    case "DisconnectPeer":
      return GRPCAsyncServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Lnrpc_DisconnectPeerRequest>(),
        responseSerializer: ProtobufSerializer<Lnrpc_DisconnectPeerResponse>(),
        interceptors: self.interceptors?.makeDisconnectPeerInterceptors() ?? [],
        wrapping: { try await self.disconnectPeer(request: $0, context: $1) }
      )

    case "ListPeers":
      return GRPCAsyncServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Lnrpc_ListPeersRequest>(),
        responseSerializer: ProtobufSerializer<Lnrpc_ListPeersResponse>(),
        interceptors: self.interceptors?.makeListPeersInterceptors() ?? [],
        wrapping: { try await self.listPeers(request: $0, context: $1) }
      )

    case "SubscribePeerEvents":
      return GRPCAsyncServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Lnrpc_PeerEventSubscription>(),
        responseSerializer: ProtobufSerializer<Lnrpc_PeerEvent>(),
        interceptors: self.interceptors?.makeSubscribePeerEventsInterceptors() ?? [],
        wrapping: { try await self.subscribePeerEvents(request: $0, responseStream: $1, context: $2) }
      )

    case "GetInfo":
      return GRPCAsyncServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Lnrpc_GetInfoRequest>(),
        responseSerializer: ProtobufSerializer<Lnrpc_GetInfoResponse>(),
        interceptors: self.interceptors?.makeGetInfoInterceptors() ?? [],
        wrapping: { try await self.getInfo(request: $0, context: $1) }
      )

    case "GetRecoveryInfo":
      return GRPCAsyncServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Lnrpc_GetRecoveryInfoRequest>(),
        responseSerializer: ProtobufSerializer<Lnrpc_GetRecoveryInfoResponse>(),
        interceptors: self.interceptors?.makeGetRecoveryInfoInterceptors() ?? [],
        wrapping: { try await self.getRecoveryInfo(request: $0, context: $1) }
      )

    case "PendingChannels":
      return GRPCAsyncServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Lnrpc_PendingChannelsRequest>(),
        responseSerializer: ProtobufSerializer<Lnrpc_PendingChannelsResponse>(),
        interceptors: self.interceptors?.makePendingChannelsInterceptors() ?? [],
        wrapping: { try await self.pendingChannels(request: $0, context: $1) }
      )

    case "ListChannels":
      return GRPCAsyncServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Lnrpc_ListChannelsRequest>(),
        responseSerializer: ProtobufSerializer<Lnrpc_ListChannelsResponse>(),
        interceptors: self.interceptors?.makeListChannelsInterceptors() ?? [],
        wrapping: { try await self.listChannels(request: $0, context: $1) }
      )

    case "SubscribeChannelEvents":
      return GRPCAsyncServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Lnrpc_ChannelEventSubscription>(),
        responseSerializer: ProtobufSerializer<Lnrpc_ChannelEventUpdate>(),
        interceptors: self.interceptors?.makeSubscribeChannelEventsInterceptors() ?? [],
        wrapping: { try await self.subscribeChannelEvents(request: $0, responseStream: $1, context: $2) }
      )

    case "ClosedChannels":
      return GRPCAsyncServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Lnrpc_ClosedChannelsRequest>(),
        responseSerializer: ProtobufSerializer<Lnrpc_ClosedChannelsResponse>(),
        interceptors: self.interceptors?.makeClosedChannelsInterceptors() ?? [],
        wrapping: { try await self.closedChannels(request: $0, context: $1) }
      )

    case "OpenChannelSync":
      return GRPCAsyncServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Lnrpc_OpenChannelRequest>(),
        responseSerializer: ProtobufSerializer<Lnrpc_ChannelPoint>(),
        interceptors: self.interceptors?.makeOpenChannelSyncInterceptors() ?? [],
        wrapping: { try await self.openChannelSync(request: $0, context: $1) }
      )

    case "OpenChannel":
      return GRPCAsyncServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Lnrpc_OpenChannelRequest>(),
        responseSerializer: ProtobufSerializer<Lnrpc_OpenStatusUpdate>(),
        interceptors: self.interceptors?.makeOpenChannelInterceptors() ?? [],
        wrapping: { try await self.openChannel(request: $0, responseStream: $1, context: $2) }
      )

    case "BatchOpenChannel":
      return GRPCAsyncServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Lnrpc_BatchOpenChannelRequest>(),
        responseSerializer: ProtobufSerializer<Lnrpc_BatchOpenChannelResponse>(),
        interceptors: self.interceptors?.makeBatchOpenChannelInterceptors() ?? [],
        wrapping: { try await self.batchOpenChannel(request: $0, context: $1) }
      )

    case "FundingStateStep":
      return GRPCAsyncServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Lnrpc_FundingTransitionMsg>(),
        responseSerializer: ProtobufSerializer<Lnrpc_FundingStateStepResp>(),
        interceptors: self.interceptors?.makeFundingStateStepInterceptors() ?? [],
        wrapping: { try await self.fundingStateStep(request: $0, context: $1) }
      )

    case "ChannelAcceptor":
      return GRPCAsyncServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Lnrpc_ChannelAcceptResponse>(),
        responseSerializer: ProtobufSerializer<Lnrpc_ChannelAcceptRequest>(),
        interceptors: self.interceptors?.makeChannelAcceptorInterceptors() ?? [],
        wrapping: { try await self.channelAcceptor(requestStream: $0, responseStream: $1, context: $2) }
      )

    case "CloseChannel":
      return GRPCAsyncServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Lnrpc_CloseChannelRequest>(),
        responseSerializer: ProtobufSerializer<Lnrpc_CloseStatusUpdate>(),
        interceptors: self.interceptors?.makeCloseChannelInterceptors() ?? [],
        wrapping: { try await self.closeChannel(request: $0, responseStream: $1, context: $2) }
      )

    case "AbandonChannel":
      return GRPCAsyncServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Lnrpc_AbandonChannelRequest>(),
        responseSerializer: ProtobufSerializer<Lnrpc_AbandonChannelResponse>(),
        interceptors: self.interceptors?.makeAbandonChannelInterceptors() ?? [],
        wrapping: { try await self.abandonChannel(request: $0, context: $1) }
      )

    case "SendPayment":
      return GRPCAsyncServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Lnrpc_SendRequest>(),
        responseSerializer: ProtobufSerializer<Lnrpc_SendResponse>(),
        interceptors: self.interceptors?.makeSendPaymentInterceptors() ?? [],
        wrapping: { try await self.sendPayment(requestStream: $0, responseStream: $1, context: $2) }
      )

    case "SendPaymentSync":
      return GRPCAsyncServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Lnrpc_SendRequest>(),
        responseSerializer: ProtobufSerializer<Lnrpc_SendResponse>(),
        interceptors: self.interceptors?.makeSendPaymentSyncInterceptors() ?? [],
        wrapping: { try await self.sendPaymentSync(request: $0, context: $1) }
      )

    case "SendToRoute":
      return GRPCAsyncServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Lnrpc_SendToRouteRequest>(),
        responseSerializer: ProtobufSerializer<Lnrpc_SendResponse>(),
        interceptors: self.interceptors?.makeSendToRouteInterceptors() ?? [],
        wrapping: { try await self.sendToRoute(requestStream: $0, responseStream: $1, context: $2) }
      )

    case "SendToRouteSync":
      return GRPCAsyncServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Lnrpc_SendToRouteRequest>(),
        responseSerializer: ProtobufSerializer<Lnrpc_SendResponse>(),
        interceptors: self.interceptors?.makeSendToRouteSyncInterceptors() ?? [],
        wrapping: { try await self.sendToRouteSync(request: $0, context: $1) }
      )

    case "AddInvoice":
      return GRPCAsyncServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Lnrpc_Invoice>(),
        responseSerializer: ProtobufSerializer<Lnrpc_AddInvoiceResponse>(),
        interceptors: self.interceptors?.makeAddInvoiceInterceptors() ?? [],
        wrapping: { try await self.addInvoice(request: $0, context: $1) }
      )

    case "ListInvoices":
      return GRPCAsyncServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Lnrpc_ListInvoiceRequest>(),
        responseSerializer: ProtobufSerializer<Lnrpc_ListInvoiceResponse>(),
        interceptors: self.interceptors?.makeListInvoicesInterceptors() ?? [],
        wrapping: { try await self.listInvoices(request: $0, context: $1) }
      )

    case "LookupInvoice":
      return GRPCAsyncServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Lnrpc_PaymentHash>(),
        responseSerializer: ProtobufSerializer<Lnrpc_Invoice>(),
        interceptors: self.interceptors?.makeLookupInvoiceInterceptors() ?? [],
        wrapping: { try await self.lookupInvoice(request: $0, context: $1) }
      )

    case "SubscribeInvoices":
      return GRPCAsyncServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Lnrpc_InvoiceSubscription>(),
        responseSerializer: ProtobufSerializer<Lnrpc_Invoice>(),
        interceptors: self.interceptors?.makeSubscribeInvoicesInterceptors() ?? [],
        wrapping: { try await self.subscribeInvoices(request: $0, responseStream: $1, context: $2) }
      )

    case "DecodePayReq":
      return GRPCAsyncServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Lnrpc_PayReqString>(),
        responseSerializer: ProtobufSerializer<Lnrpc_PayReq>(),
        interceptors: self.interceptors?.makeDecodePayReqInterceptors() ?? [],
        wrapping: { try await self.decodePayReq(request: $0, context: $1) }
      )

    case "ListPayments":
      return GRPCAsyncServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Lnrpc_ListPaymentsRequest>(),
        responseSerializer: ProtobufSerializer<Lnrpc_ListPaymentsResponse>(),
        interceptors: self.interceptors?.makeListPaymentsInterceptors() ?? [],
        wrapping: { try await self.listPayments(request: $0, context: $1) }
      )

    case "DeletePayment":
      return GRPCAsyncServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Lnrpc_DeletePaymentRequest>(),
        responseSerializer: ProtobufSerializer<Lnrpc_DeletePaymentResponse>(),
        interceptors: self.interceptors?.makeDeletePaymentInterceptors() ?? [],
        wrapping: { try await self.deletePayment(request: $0, context: $1) }
      )

    case "DeleteAllPayments":
      return GRPCAsyncServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Lnrpc_DeleteAllPaymentsRequest>(),
        responseSerializer: ProtobufSerializer<Lnrpc_DeleteAllPaymentsResponse>(),
        interceptors: self.interceptors?.makeDeleteAllPaymentsInterceptors() ?? [],
        wrapping: { try await self.deleteAllPayments(request: $0, context: $1) }
      )

    case "DescribeGraph":
      return GRPCAsyncServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Lnrpc_ChannelGraphRequest>(),
        responseSerializer: ProtobufSerializer<Lnrpc_ChannelGraph>(),
        interceptors: self.interceptors?.makeDescribeGraphInterceptors() ?? [],
        wrapping: { try await self.describeGraph(request: $0, context: $1) }
      )

    case "GetNodeMetrics":
      return GRPCAsyncServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Lnrpc_NodeMetricsRequest>(),
        responseSerializer: ProtobufSerializer<Lnrpc_NodeMetricsResponse>(),
        interceptors: self.interceptors?.makeGetNodeMetricsInterceptors() ?? [],
        wrapping: { try await self.getNodeMetrics(request: $0, context: $1) }
      )

    case "GetChanInfo":
      return GRPCAsyncServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Lnrpc_ChanInfoRequest>(),
        responseSerializer: ProtobufSerializer<Lnrpc_ChannelEdge>(),
        interceptors: self.interceptors?.makeGetChanInfoInterceptors() ?? [],
        wrapping: { try await self.getChanInfo(request: $0, context: $1) }
      )

    case "GetNodeInfo":
      return GRPCAsyncServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Lnrpc_NodeInfoRequest>(),
        responseSerializer: ProtobufSerializer<Lnrpc_NodeInfo>(),
        interceptors: self.interceptors?.makeGetNodeInfoInterceptors() ?? [],
        wrapping: { try await self.getNodeInfo(request: $0, context: $1) }
      )

    case "QueryRoutes":
      return GRPCAsyncServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Lnrpc_QueryRoutesRequest>(),
        responseSerializer: ProtobufSerializer<Lnrpc_QueryRoutesResponse>(),
        interceptors: self.interceptors?.makeQueryRoutesInterceptors() ?? [],
        wrapping: { try await self.queryRoutes(request: $0, context: $1) }
      )

    case "GetNetworkInfo":
      return GRPCAsyncServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Lnrpc_NetworkInfoRequest>(),
        responseSerializer: ProtobufSerializer<Lnrpc_NetworkInfo>(),
        interceptors: self.interceptors?.makeGetNetworkInfoInterceptors() ?? [],
        wrapping: { try await self.getNetworkInfo(request: $0, context: $1) }
      )

    case "StopDaemon":
      return GRPCAsyncServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Lnrpc_StopRequest>(),
        responseSerializer: ProtobufSerializer<Lnrpc_StopResponse>(),
        interceptors: self.interceptors?.makeStopDaemonInterceptors() ?? [],
        wrapping: { try await self.stopDaemon(request: $0, context: $1) }
      )

    case "SubscribeChannelGraph":
      return GRPCAsyncServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Lnrpc_GraphTopologySubscription>(),
        responseSerializer: ProtobufSerializer<Lnrpc_GraphTopologyUpdate>(),
        interceptors: self.interceptors?.makeSubscribeChannelGraphInterceptors() ?? [],
        wrapping: { try await self.subscribeChannelGraph(request: $0, responseStream: $1, context: $2) }
      )

    case "DebugLevel":
      return GRPCAsyncServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Lnrpc_DebugLevelRequest>(),
        responseSerializer: ProtobufSerializer<Lnrpc_DebugLevelResponse>(),
        interceptors: self.interceptors?.makeDebugLevelInterceptors() ?? [],
        wrapping: { try await self.debugLevel(request: $0, context: $1) }
      )

    case "FeeReport":
      return GRPCAsyncServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Lnrpc_FeeReportRequest>(),
        responseSerializer: ProtobufSerializer<Lnrpc_FeeReportResponse>(),
        interceptors: self.interceptors?.makeFeeReportInterceptors() ?? [],
        wrapping: { try await self.feeReport(request: $0, context: $1) }
      )

    case "UpdateChannelPolicy":
      return GRPCAsyncServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Lnrpc_PolicyUpdateRequest>(),
        responseSerializer: ProtobufSerializer<Lnrpc_PolicyUpdateResponse>(),
        interceptors: self.interceptors?.makeUpdateChannelPolicyInterceptors() ?? [],
        wrapping: { try await self.updateChannelPolicy(request: $0, context: $1) }
      )

    case "ForwardingHistory":
      return GRPCAsyncServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Lnrpc_ForwardingHistoryRequest>(),
        responseSerializer: ProtobufSerializer<Lnrpc_ForwardingHistoryResponse>(),
        interceptors: self.interceptors?.makeForwardingHistoryInterceptors() ?? [],
        wrapping: { try await self.forwardingHistory(request: $0, context: $1) }
      )

    case "ExportChannelBackup":
      return GRPCAsyncServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Lnrpc_ExportChannelBackupRequest>(),
        responseSerializer: ProtobufSerializer<Lnrpc_ChannelBackup>(),
        interceptors: self.interceptors?.makeExportChannelBackupInterceptors() ?? [],
        wrapping: { try await self.exportChannelBackup(request: $0, context: $1) }
      )

    case "ExportAllChannelBackups":
      return GRPCAsyncServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Lnrpc_ChanBackupExportRequest>(),
        responseSerializer: ProtobufSerializer<Lnrpc_ChanBackupSnapshot>(),
        interceptors: self.interceptors?.makeExportAllChannelBackupsInterceptors() ?? [],
        wrapping: { try await self.exportAllChannelBackups(request: $0, context: $1) }
      )

    case "VerifyChanBackup":
      return GRPCAsyncServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Lnrpc_ChanBackupSnapshot>(),
        responseSerializer: ProtobufSerializer<Lnrpc_VerifyChanBackupResponse>(),
        interceptors: self.interceptors?.makeVerifyChanBackupInterceptors() ?? [],
        wrapping: { try await self.verifyChanBackup(request: $0, context: $1) }
      )

    case "RestoreChannelBackups":
      return GRPCAsyncServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Lnrpc_RestoreChanBackupRequest>(),
        responseSerializer: ProtobufSerializer<Lnrpc_RestoreBackupResponse>(),
        interceptors: self.interceptors?.makeRestoreChannelBackupsInterceptors() ?? [],
        wrapping: { try await self.restoreChannelBackups(request: $0, context: $1) }
      )

    case "SubscribeChannelBackups":
      return GRPCAsyncServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Lnrpc_ChannelBackupSubscription>(),
        responseSerializer: ProtobufSerializer<Lnrpc_ChanBackupSnapshot>(),
        interceptors: self.interceptors?.makeSubscribeChannelBackupsInterceptors() ?? [],
        wrapping: { try await self.subscribeChannelBackups(request: $0, responseStream: $1, context: $2) }
      )

    case "BakeMacaroon":
      return GRPCAsyncServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Lnrpc_BakeMacaroonRequest>(),
        responseSerializer: ProtobufSerializer<Lnrpc_BakeMacaroonResponse>(),
        interceptors: self.interceptors?.makeBakeMacaroonInterceptors() ?? [],
        wrapping: { try await self.bakeMacaroon(request: $0, context: $1) }
      )

    case "ListMacaroonIDs":
      return GRPCAsyncServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Lnrpc_ListMacaroonIDsRequest>(),
        responseSerializer: ProtobufSerializer<Lnrpc_ListMacaroonIDsResponse>(),
        interceptors: self.interceptors?.makeListMacaroonIDsInterceptors() ?? [],
        wrapping: { try await self.listMacaroonIDs(request: $0, context: $1) }
      )

    case "DeleteMacaroonID":
      return GRPCAsyncServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Lnrpc_DeleteMacaroonIDRequest>(),
        responseSerializer: ProtobufSerializer<Lnrpc_DeleteMacaroonIDResponse>(),
        interceptors: self.interceptors?.makeDeleteMacaroonIDInterceptors() ?? [],
        wrapping: { try await self.deleteMacaroonID(request: $0, context: $1) }
      )

    case "ListPermissions":
      return GRPCAsyncServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Lnrpc_ListPermissionsRequest>(),
        responseSerializer: ProtobufSerializer<Lnrpc_ListPermissionsResponse>(),
        interceptors: self.interceptors?.makeListPermissionsInterceptors() ?? [],
        wrapping: { try await self.listPermissions(request: $0, context: $1) }
      )

    case "CheckMacaroonPermissions":
      return GRPCAsyncServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Lnrpc_CheckMacPermRequest>(),
        responseSerializer: ProtobufSerializer<Lnrpc_CheckMacPermResponse>(),
        interceptors: self.interceptors?.makeCheckMacaroonPermissionsInterceptors() ?? [],
        wrapping: { try await self.checkMacaroonPermissions(request: $0, context: $1) }
      )

    case "RegisterRPCMiddleware":
      return GRPCAsyncServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Lnrpc_RPCMiddlewareResponse>(),
        responseSerializer: ProtobufSerializer<Lnrpc_RPCMiddlewareRequest>(),
        interceptors: self.interceptors?.makeRegisterRPCMiddlewareInterceptors() ?? [],
        wrapping: { try await self.registerRPCMiddleware(requestStream: $0, responseStream: $1, context: $2) }
      )

    case "SendCustomMessage":
      return GRPCAsyncServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Lnrpc_SendCustomMessageRequest>(),
        responseSerializer: ProtobufSerializer<Lnrpc_SendCustomMessageResponse>(),
        interceptors: self.interceptors?.makeSendCustomMessageInterceptors() ?? [],
        wrapping: { try await self.sendCustomMessage(request: $0, context: $1) }
      )

    case "SubscribeCustomMessages":
      return GRPCAsyncServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Lnrpc_SubscribeCustomMessagesRequest>(),
        responseSerializer: ProtobufSerializer<Lnrpc_CustomMessage>(),
        interceptors: self.interceptors?.makeSubscribeCustomMessagesInterceptors() ?? [],
        wrapping: { try await self.subscribeCustomMessages(request: $0, responseStream: $1, context: $2) }
      )

    case "ListAliases":
      return GRPCAsyncServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Lnrpc_ListAliasesRequest>(),
        responseSerializer: ProtobufSerializer<Lnrpc_ListAliasesResponse>(),
        interceptors: self.interceptors?.makeListAliasesInterceptors() ?? [],
        wrapping: { try await self.listAliases(request: $0, context: $1) }
      )

    case "LookupHtlcResolution":
      return GRPCAsyncServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Lnrpc_LookupHtlcResolutionRequest>(),
        responseSerializer: ProtobufSerializer<Lnrpc_LookupHtlcResolutionResponse>(),
        interceptors: self.interceptors?.makeLookupHtlcResolutionInterceptors() ?? [],
        wrapping: { try await self.lookupHtlcResolution(request: $0, context: $1) }
      )

    default:
      return nil
    }
  }
}

internal protocol Lnrpc_LightningServerInterceptorFactoryProtocol: Sendable {

  /// - Returns: Interceptors to use when handling 'walletBalance'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makeWalletBalanceInterceptors() -> [ServerInterceptor<Lnrpc_WalletBalanceRequest, Lnrpc_WalletBalanceResponse>]

  /// - Returns: Interceptors to use when handling 'channelBalance'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makeChannelBalanceInterceptors() -> [ServerInterceptor<Lnrpc_ChannelBalanceRequest, Lnrpc_ChannelBalanceResponse>]

  /// - Returns: Interceptors to use when handling 'getTransactions'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makeGetTransactionsInterceptors() -> [ServerInterceptor<Lnrpc_GetTransactionsRequest, Lnrpc_TransactionDetails>]

  /// - Returns: Interceptors to use when handling 'estimateFee'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makeEstimateFeeInterceptors() -> [ServerInterceptor<Lnrpc_EstimateFeeRequest, Lnrpc_EstimateFeeResponse>]

  /// - Returns: Interceptors to use when handling 'sendCoins'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makeSendCoinsInterceptors() -> [ServerInterceptor<Lnrpc_SendCoinsRequest, Lnrpc_SendCoinsResponse>]

  /// - Returns: Interceptors to use when handling 'listUnspent'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makeListUnspentInterceptors() -> [ServerInterceptor<Lnrpc_ListUnspentRequest, Lnrpc_ListUnspentResponse>]

  /// - Returns: Interceptors to use when handling 'subscribeTransactions'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makeSubscribeTransactionsInterceptors() -> [ServerInterceptor<Lnrpc_GetTransactionsRequest, Lnrpc_Transaction>]

  /// - Returns: Interceptors to use when handling 'sendMany'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makeSendManyInterceptors() -> [ServerInterceptor<Lnrpc_SendManyRequest, Lnrpc_SendManyResponse>]

  /// - Returns: Interceptors to use when handling 'newAddress'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makeNewAddressInterceptors() -> [ServerInterceptor<Lnrpc_NewAddressRequest, Lnrpc_NewAddressResponse>]

  /// - Returns: Interceptors to use when handling 'signMessage'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makeSignMessageInterceptors() -> [ServerInterceptor<Lnrpc_SignMessageRequest, Lnrpc_SignMessageResponse>]

  /// - Returns: Interceptors to use when handling 'verifyMessage'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makeVerifyMessageInterceptors() -> [ServerInterceptor<Lnrpc_VerifyMessageRequest, Lnrpc_VerifyMessageResponse>]

  /// - Returns: Interceptors to use when handling 'connectPeer'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makeConnectPeerInterceptors() -> [ServerInterceptor<Lnrpc_ConnectPeerRequest, Lnrpc_ConnectPeerResponse>]

  /// - Returns: Interceptors to use when handling 'disconnectPeer'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makeDisconnectPeerInterceptors() -> [ServerInterceptor<Lnrpc_DisconnectPeerRequest, Lnrpc_DisconnectPeerResponse>]

  /// - Returns: Interceptors to use when handling 'listPeers'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makeListPeersInterceptors() -> [ServerInterceptor<Lnrpc_ListPeersRequest, Lnrpc_ListPeersResponse>]

  /// - Returns: Interceptors to use when handling 'subscribePeerEvents'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makeSubscribePeerEventsInterceptors() -> [ServerInterceptor<Lnrpc_PeerEventSubscription, Lnrpc_PeerEvent>]

  /// - Returns: Interceptors to use when handling 'getInfo'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makeGetInfoInterceptors() -> [ServerInterceptor<Lnrpc_GetInfoRequest, Lnrpc_GetInfoResponse>]

  /// - Returns: Interceptors to use when handling 'getRecoveryInfo'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makeGetRecoveryInfoInterceptors() -> [ServerInterceptor<Lnrpc_GetRecoveryInfoRequest, Lnrpc_GetRecoveryInfoResponse>]

  /// - Returns: Interceptors to use when handling 'pendingChannels'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makePendingChannelsInterceptors() -> [ServerInterceptor<Lnrpc_PendingChannelsRequest, Lnrpc_PendingChannelsResponse>]

  /// - Returns: Interceptors to use when handling 'listChannels'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makeListChannelsInterceptors() -> [ServerInterceptor<Lnrpc_ListChannelsRequest, Lnrpc_ListChannelsResponse>]

  /// - Returns: Interceptors to use when handling 'subscribeChannelEvents'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makeSubscribeChannelEventsInterceptors() -> [ServerInterceptor<Lnrpc_ChannelEventSubscription, Lnrpc_ChannelEventUpdate>]

  /// - Returns: Interceptors to use when handling 'closedChannels'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makeClosedChannelsInterceptors() -> [ServerInterceptor<Lnrpc_ClosedChannelsRequest, Lnrpc_ClosedChannelsResponse>]

  /// - Returns: Interceptors to use when handling 'openChannelSync'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makeOpenChannelSyncInterceptors() -> [ServerInterceptor<Lnrpc_OpenChannelRequest, Lnrpc_ChannelPoint>]

  /// - Returns: Interceptors to use when handling 'openChannel'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makeOpenChannelInterceptors() -> [ServerInterceptor<Lnrpc_OpenChannelRequest, Lnrpc_OpenStatusUpdate>]

  /// - Returns: Interceptors to use when handling 'batchOpenChannel'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makeBatchOpenChannelInterceptors() -> [ServerInterceptor<Lnrpc_BatchOpenChannelRequest, Lnrpc_BatchOpenChannelResponse>]

  /// - Returns: Interceptors to use when handling 'fundingStateStep'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makeFundingStateStepInterceptors() -> [ServerInterceptor<Lnrpc_FundingTransitionMsg, Lnrpc_FundingStateStepResp>]

  /// - Returns: Interceptors to use when handling 'channelAcceptor'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makeChannelAcceptorInterceptors() -> [ServerInterceptor<Lnrpc_ChannelAcceptResponse, Lnrpc_ChannelAcceptRequest>]

  /// - Returns: Interceptors to use when handling 'closeChannel'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makeCloseChannelInterceptors() -> [ServerInterceptor<Lnrpc_CloseChannelRequest, Lnrpc_CloseStatusUpdate>]

  /// - Returns: Interceptors to use when handling 'abandonChannel'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makeAbandonChannelInterceptors() -> [ServerInterceptor<Lnrpc_AbandonChannelRequest, Lnrpc_AbandonChannelResponse>]

  /// - Returns: Interceptors to use when handling 'sendPayment'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makeSendPaymentInterceptors() -> [ServerInterceptor<Lnrpc_SendRequest, Lnrpc_SendResponse>]

  /// - Returns: Interceptors to use when handling 'sendPaymentSync'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makeSendPaymentSyncInterceptors() -> [ServerInterceptor<Lnrpc_SendRequest, Lnrpc_SendResponse>]

  /// - Returns: Interceptors to use when handling 'sendToRoute'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makeSendToRouteInterceptors() -> [ServerInterceptor<Lnrpc_SendToRouteRequest, Lnrpc_SendResponse>]

  /// - Returns: Interceptors to use when handling 'sendToRouteSync'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makeSendToRouteSyncInterceptors() -> [ServerInterceptor<Lnrpc_SendToRouteRequest, Lnrpc_SendResponse>]

  /// - Returns: Interceptors to use when handling 'addInvoice'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makeAddInvoiceInterceptors() -> [ServerInterceptor<Lnrpc_Invoice, Lnrpc_AddInvoiceResponse>]

  /// - Returns: Interceptors to use when handling 'listInvoices'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makeListInvoicesInterceptors() -> [ServerInterceptor<Lnrpc_ListInvoiceRequest, Lnrpc_ListInvoiceResponse>]

  /// - Returns: Interceptors to use when handling 'lookupInvoice'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makeLookupInvoiceInterceptors() -> [ServerInterceptor<Lnrpc_PaymentHash, Lnrpc_Invoice>]

  /// - Returns: Interceptors to use when handling 'subscribeInvoices'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makeSubscribeInvoicesInterceptors() -> [ServerInterceptor<Lnrpc_InvoiceSubscription, Lnrpc_Invoice>]

  /// - Returns: Interceptors to use when handling 'decodePayReq'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makeDecodePayReqInterceptors() -> [ServerInterceptor<Lnrpc_PayReqString, Lnrpc_PayReq>]

  /// - Returns: Interceptors to use when handling 'listPayments'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makeListPaymentsInterceptors() -> [ServerInterceptor<Lnrpc_ListPaymentsRequest, Lnrpc_ListPaymentsResponse>]

  /// - Returns: Interceptors to use when handling 'deletePayment'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makeDeletePaymentInterceptors() -> [ServerInterceptor<Lnrpc_DeletePaymentRequest, Lnrpc_DeletePaymentResponse>]

  /// - Returns: Interceptors to use when handling 'deleteAllPayments'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makeDeleteAllPaymentsInterceptors() -> [ServerInterceptor<Lnrpc_DeleteAllPaymentsRequest, Lnrpc_DeleteAllPaymentsResponse>]

  /// - Returns: Interceptors to use when handling 'describeGraph'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makeDescribeGraphInterceptors() -> [ServerInterceptor<Lnrpc_ChannelGraphRequest, Lnrpc_ChannelGraph>]

  /// - Returns: Interceptors to use when handling 'getNodeMetrics'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makeGetNodeMetricsInterceptors() -> [ServerInterceptor<Lnrpc_NodeMetricsRequest, Lnrpc_NodeMetricsResponse>]

  /// - Returns: Interceptors to use when handling 'getChanInfo'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makeGetChanInfoInterceptors() -> [ServerInterceptor<Lnrpc_ChanInfoRequest, Lnrpc_ChannelEdge>]

  /// - Returns: Interceptors to use when handling 'getNodeInfo'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makeGetNodeInfoInterceptors() -> [ServerInterceptor<Lnrpc_NodeInfoRequest, Lnrpc_NodeInfo>]

  /// - Returns: Interceptors to use when handling 'queryRoutes'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makeQueryRoutesInterceptors() -> [ServerInterceptor<Lnrpc_QueryRoutesRequest, Lnrpc_QueryRoutesResponse>]

  /// - Returns: Interceptors to use when handling 'getNetworkInfo'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makeGetNetworkInfoInterceptors() -> [ServerInterceptor<Lnrpc_NetworkInfoRequest, Lnrpc_NetworkInfo>]

  /// - Returns: Interceptors to use when handling 'stopDaemon'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makeStopDaemonInterceptors() -> [ServerInterceptor<Lnrpc_StopRequest, Lnrpc_StopResponse>]

  /// - Returns: Interceptors to use when handling 'subscribeChannelGraph'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makeSubscribeChannelGraphInterceptors() -> [ServerInterceptor<Lnrpc_GraphTopologySubscription, Lnrpc_GraphTopologyUpdate>]

  /// - Returns: Interceptors to use when handling 'debugLevel'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makeDebugLevelInterceptors() -> [ServerInterceptor<Lnrpc_DebugLevelRequest, Lnrpc_DebugLevelResponse>]

  /// - Returns: Interceptors to use when handling 'feeReport'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makeFeeReportInterceptors() -> [ServerInterceptor<Lnrpc_FeeReportRequest, Lnrpc_FeeReportResponse>]

  /// - Returns: Interceptors to use when handling 'updateChannelPolicy'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makeUpdateChannelPolicyInterceptors() -> [ServerInterceptor<Lnrpc_PolicyUpdateRequest, Lnrpc_PolicyUpdateResponse>]

  /// - Returns: Interceptors to use when handling 'forwardingHistory'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makeForwardingHistoryInterceptors() -> [ServerInterceptor<Lnrpc_ForwardingHistoryRequest, Lnrpc_ForwardingHistoryResponse>]

  /// - Returns: Interceptors to use when handling 'exportChannelBackup'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makeExportChannelBackupInterceptors() -> [ServerInterceptor<Lnrpc_ExportChannelBackupRequest, Lnrpc_ChannelBackup>]

  /// - Returns: Interceptors to use when handling 'exportAllChannelBackups'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makeExportAllChannelBackupsInterceptors() -> [ServerInterceptor<Lnrpc_ChanBackupExportRequest, Lnrpc_ChanBackupSnapshot>]

  /// - Returns: Interceptors to use when handling 'verifyChanBackup'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makeVerifyChanBackupInterceptors() -> [ServerInterceptor<Lnrpc_ChanBackupSnapshot, Lnrpc_VerifyChanBackupResponse>]

  /// - Returns: Interceptors to use when handling 'restoreChannelBackups'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makeRestoreChannelBackupsInterceptors() -> [ServerInterceptor<Lnrpc_RestoreChanBackupRequest, Lnrpc_RestoreBackupResponse>]

  /// - Returns: Interceptors to use when handling 'subscribeChannelBackups'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makeSubscribeChannelBackupsInterceptors() -> [ServerInterceptor<Lnrpc_ChannelBackupSubscription, Lnrpc_ChanBackupSnapshot>]

  /// - Returns: Interceptors to use when handling 'bakeMacaroon'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makeBakeMacaroonInterceptors() -> [ServerInterceptor<Lnrpc_BakeMacaroonRequest, Lnrpc_BakeMacaroonResponse>]

  /// - Returns: Interceptors to use when handling 'listMacaroonIDs'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makeListMacaroonIDsInterceptors() -> [ServerInterceptor<Lnrpc_ListMacaroonIDsRequest, Lnrpc_ListMacaroonIDsResponse>]

  /// - Returns: Interceptors to use when handling 'deleteMacaroonID'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makeDeleteMacaroonIDInterceptors() -> [ServerInterceptor<Lnrpc_DeleteMacaroonIDRequest, Lnrpc_DeleteMacaroonIDResponse>]

  /// - Returns: Interceptors to use when handling 'listPermissions'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makeListPermissionsInterceptors() -> [ServerInterceptor<Lnrpc_ListPermissionsRequest, Lnrpc_ListPermissionsResponse>]

  /// - Returns: Interceptors to use when handling 'checkMacaroonPermissions'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makeCheckMacaroonPermissionsInterceptors() -> [ServerInterceptor<Lnrpc_CheckMacPermRequest, Lnrpc_CheckMacPermResponse>]

  /// - Returns: Interceptors to use when handling 'registerRPCMiddleware'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makeRegisterRPCMiddlewareInterceptors() -> [ServerInterceptor<Lnrpc_RPCMiddlewareResponse, Lnrpc_RPCMiddlewareRequest>]

  /// - Returns: Interceptors to use when handling 'sendCustomMessage'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makeSendCustomMessageInterceptors() -> [ServerInterceptor<Lnrpc_SendCustomMessageRequest, Lnrpc_SendCustomMessageResponse>]

  /// - Returns: Interceptors to use when handling 'subscribeCustomMessages'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makeSubscribeCustomMessagesInterceptors() -> [ServerInterceptor<Lnrpc_SubscribeCustomMessagesRequest, Lnrpc_CustomMessage>]

  /// - Returns: Interceptors to use when handling 'listAliases'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makeListAliasesInterceptors() -> [ServerInterceptor<Lnrpc_ListAliasesRequest, Lnrpc_ListAliasesResponse>]

  /// - Returns: Interceptors to use when handling 'lookupHtlcResolution'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makeLookupHtlcResolutionInterceptors() -> [ServerInterceptor<Lnrpc_LookupHtlcResolutionRequest, Lnrpc_LookupHtlcResolutionResponse>]
}

internal enum Lnrpc_LightningServerMetadata {
  internal static let serviceDescriptor = GRPCServiceDescriptor(
    name: "Lightning",
    fullName: "lnrpc.Lightning",
    methods: [
      Lnrpc_LightningServerMetadata.Methods.walletBalance,
      Lnrpc_LightningServerMetadata.Methods.channelBalance,
      Lnrpc_LightningServerMetadata.Methods.getTransactions,
      Lnrpc_LightningServerMetadata.Methods.estimateFee,
      Lnrpc_LightningServerMetadata.Methods.sendCoins,
      Lnrpc_LightningServerMetadata.Methods.listUnspent,
      Lnrpc_LightningServerMetadata.Methods.subscribeTransactions,
      Lnrpc_LightningServerMetadata.Methods.sendMany,
      Lnrpc_LightningServerMetadata.Methods.newAddress,
      Lnrpc_LightningServerMetadata.Methods.signMessage,
      Lnrpc_LightningServerMetadata.Methods.verifyMessage,
      Lnrpc_LightningServerMetadata.Methods.connectPeer,
      Lnrpc_LightningServerMetadata.Methods.disconnectPeer,
      Lnrpc_LightningServerMetadata.Methods.listPeers,
      Lnrpc_LightningServerMetadata.Methods.subscribePeerEvents,
      Lnrpc_LightningServerMetadata.Methods.getInfo,
      Lnrpc_LightningServerMetadata.Methods.getRecoveryInfo,
      Lnrpc_LightningServerMetadata.Methods.pendingChannels,
      Lnrpc_LightningServerMetadata.Methods.listChannels,
      Lnrpc_LightningServerMetadata.Methods.subscribeChannelEvents,
      Lnrpc_LightningServerMetadata.Methods.closedChannels,
      Lnrpc_LightningServerMetadata.Methods.openChannelSync,
      Lnrpc_LightningServerMetadata.Methods.openChannel,
      Lnrpc_LightningServerMetadata.Methods.batchOpenChannel,
      Lnrpc_LightningServerMetadata.Methods.fundingStateStep,
      Lnrpc_LightningServerMetadata.Methods.channelAcceptor,
      Lnrpc_LightningServerMetadata.Methods.closeChannel,
      Lnrpc_LightningServerMetadata.Methods.abandonChannel,
      Lnrpc_LightningServerMetadata.Methods.sendPayment,
      Lnrpc_LightningServerMetadata.Methods.sendPaymentSync,
      Lnrpc_LightningServerMetadata.Methods.sendToRoute,
      Lnrpc_LightningServerMetadata.Methods.sendToRouteSync,
      Lnrpc_LightningServerMetadata.Methods.addInvoice,
      Lnrpc_LightningServerMetadata.Methods.listInvoices,
      Lnrpc_LightningServerMetadata.Methods.lookupInvoice,
      Lnrpc_LightningServerMetadata.Methods.subscribeInvoices,
      Lnrpc_LightningServerMetadata.Methods.decodePayReq,
      Lnrpc_LightningServerMetadata.Methods.listPayments,
      Lnrpc_LightningServerMetadata.Methods.deletePayment,
      Lnrpc_LightningServerMetadata.Methods.deleteAllPayments,
      Lnrpc_LightningServerMetadata.Methods.describeGraph,
      Lnrpc_LightningServerMetadata.Methods.getNodeMetrics,
      Lnrpc_LightningServerMetadata.Methods.getChanInfo,
      Lnrpc_LightningServerMetadata.Methods.getNodeInfo,
      Lnrpc_LightningServerMetadata.Methods.queryRoutes,
      Lnrpc_LightningServerMetadata.Methods.getNetworkInfo,
      Lnrpc_LightningServerMetadata.Methods.stopDaemon,
      Lnrpc_LightningServerMetadata.Methods.subscribeChannelGraph,
      Lnrpc_LightningServerMetadata.Methods.debugLevel,
      Lnrpc_LightningServerMetadata.Methods.feeReport,
      Lnrpc_LightningServerMetadata.Methods.updateChannelPolicy,
      Lnrpc_LightningServerMetadata.Methods.forwardingHistory,
      Lnrpc_LightningServerMetadata.Methods.exportChannelBackup,
      Lnrpc_LightningServerMetadata.Methods.exportAllChannelBackups,
      Lnrpc_LightningServerMetadata.Methods.verifyChanBackup,
      Lnrpc_LightningServerMetadata.Methods.restoreChannelBackups,
      Lnrpc_LightningServerMetadata.Methods.subscribeChannelBackups,
      Lnrpc_LightningServerMetadata.Methods.bakeMacaroon,
      Lnrpc_LightningServerMetadata.Methods.listMacaroonIDs,
      Lnrpc_LightningServerMetadata.Methods.deleteMacaroonID,
      Lnrpc_LightningServerMetadata.Methods.listPermissions,
      Lnrpc_LightningServerMetadata.Methods.checkMacaroonPermissions,
      Lnrpc_LightningServerMetadata.Methods.registerRPCMiddleware,
      Lnrpc_LightningServerMetadata.Methods.sendCustomMessage,
      Lnrpc_LightningServerMetadata.Methods.subscribeCustomMessages,
      Lnrpc_LightningServerMetadata.Methods.listAliases,
      Lnrpc_LightningServerMetadata.Methods.lookupHtlcResolution,
    ]
  )

  internal enum Methods {
    internal static let walletBalance = GRPCMethodDescriptor(
      name: "WalletBalance",
      path: "/lnrpc.Lightning/WalletBalance",
      type: GRPCCallType.unary
    )

    internal static let channelBalance = GRPCMethodDescriptor(
      name: "ChannelBalance",
      path: "/lnrpc.Lightning/ChannelBalance",
      type: GRPCCallType.unary
    )

    internal static let getTransactions = GRPCMethodDescriptor(
      name: "GetTransactions",
      path: "/lnrpc.Lightning/GetTransactions",
      type: GRPCCallType.unary
    )

    internal static let estimateFee = GRPCMethodDescriptor(
      name: "EstimateFee",
      path: "/lnrpc.Lightning/EstimateFee",
      type: GRPCCallType.unary
    )

    internal static let sendCoins = GRPCMethodDescriptor(
      name: "SendCoins",
      path: "/lnrpc.Lightning/SendCoins",
      type: GRPCCallType.unary
    )

    internal static let listUnspent = GRPCMethodDescriptor(
      name: "ListUnspent",
      path: "/lnrpc.Lightning/ListUnspent",
      type: GRPCCallType.unary
    )

    internal static let subscribeTransactions = GRPCMethodDescriptor(
      name: "SubscribeTransactions",
      path: "/lnrpc.Lightning/SubscribeTransactions",
      type: GRPCCallType.serverStreaming
    )

    internal static let sendMany = GRPCMethodDescriptor(
      name: "SendMany",
      path: "/lnrpc.Lightning/SendMany",
      type: GRPCCallType.unary
    )

    internal static let newAddress = GRPCMethodDescriptor(
      name: "NewAddress",
      path: "/lnrpc.Lightning/NewAddress",
      type: GRPCCallType.unary
    )

    internal static let signMessage = GRPCMethodDescriptor(
      name: "SignMessage",
      path: "/lnrpc.Lightning/SignMessage",
      type: GRPCCallType.unary
    )

    internal static let verifyMessage = GRPCMethodDescriptor(
      name: "VerifyMessage",
      path: "/lnrpc.Lightning/VerifyMessage",
      type: GRPCCallType.unary
    )

    internal static let connectPeer = GRPCMethodDescriptor(
      name: "ConnectPeer",
      path: "/lnrpc.Lightning/ConnectPeer",
      type: GRPCCallType.unary
    )

    internal static let disconnectPeer = GRPCMethodDescriptor(
      name: "DisconnectPeer",
      path: "/lnrpc.Lightning/DisconnectPeer",
      type: GRPCCallType.unary
    )

    internal static let listPeers = GRPCMethodDescriptor(
      name: "ListPeers",
      path: "/lnrpc.Lightning/ListPeers",
      type: GRPCCallType.unary
    )

    internal static let subscribePeerEvents = GRPCMethodDescriptor(
      name: "SubscribePeerEvents",
      path: "/lnrpc.Lightning/SubscribePeerEvents",
      type: GRPCCallType.serverStreaming
    )

    internal static let getInfo = GRPCMethodDescriptor(
      name: "GetInfo",
      path: "/lnrpc.Lightning/GetInfo",
      type: GRPCCallType.unary
    )

    internal static let getRecoveryInfo = GRPCMethodDescriptor(
      name: "GetRecoveryInfo",
      path: "/lnrpc.Lightning/GetRecoveryInfo",
      type: GRPCCallType.unary
    )

    internal static let pendingChannels = GRPCMethodDescriptor(
      name: "PendingChannels",
      path: "/lnrpc.Lightning/PendingChannels",
      type: GRPCCallType.unary
    )

    internal static let listChannels = GRPCMethodDescriptor(
      name: "ListChannels",
      path: "/lnrpc.Lightning/ListChannels",
      type: GRPCCallType.unary
    )

    internal static let subscribeChannelEvents = GRPCMethodDescriptor(
      name: "SubscribeChannelEvents",
      path: "/lnrpc.Lightning/SubscribeChannelEvents",
      type: GRPCCallType.serverStreaming
    )

    internal static let closedChannels = GRPCMethodDescriptor(
      name: "ClosedChannels",
      path: "/lnrpc.Lightning/ClosedChannels",
      type: GRPCCallType.unary
    )

    internal static let openChannelSync = GRPCMethodDescriptor(
      name: "OpenChannelSync",
      path: "/lnrpc.Lightning/OpenChannelSync",
      type: GRPCCallType.unary
    )

    internal static let openChannel = GRPCMethodDescriptor(
      name: "OpenChannel",
      path: "/lnrpc.Lightning/OpenChannel",
      type: GRPCCallType.serverStreaming
    )

    internal static let batchOpenChannel = GRPCMethodDescriptor(
      name: "BatchOpenChannel",
      path: "/lnrpc.Lightning/BatchOpenChannel",
      type: GRPCCallType.unary
    )

    internal static let fundingStateStep = GRPCMethodDescriptor(
      name: "FundingStateStep",
      path: "/lnrpc.Lightning/FundingStateStep",
      type: GRPCCallType.unary
    )

    internal static let channelAcceptor = GRPCMethodDescriptor(
      name: "ChannelAcceptor",
      path: "/lnrpc.Lightning/ChannelAcceptor",
      type: GRPCCallType.bidirectionalStreaming
    )

    internal static let closeChannel = GRPCMethodDescriptor(
      name: "CloseChannel",
      path: "/lnrpc.Lightning/CloseChannel",
      type: GRPCCallType.serverStreaming
    )

    internal static let abandonChannel = GRPCMethodDescriptor(
      name: "AbandonChannel",
      path: "/lnrpc.Lightning/AbandonChannel",
      type: GRPCCallType.unary
    )

    internal static let sendPayment = GRPCMethodDescriptor(
      name: "SendPayment",
      path: "/lnrpc.Lightning/SendPayment",
      type: GRPCCallType.bidirectionalStreaming
    )

    internal static let sendPaymentSync = GRPCMethodDescriptor(
      name: "SendPaymentSync",
      path: "/lnrpc.Lightning/SendPaymentSync",
      type: GRPCCallType.unary
    )

    internal static let sendToRoute = GRPCMethodDescriptor(
      name: "SendToRoute",
      path: "/lnrpc.Lightning/SendToRoute",
      type: GRPCCallType.bidirectionalStreaming
    )

    internal static let sendToRouteSync = GRPCMethodDescriptor(
      name: "SendToRouteSync",
      path: "/lnrpc.Lightning/SendToRouteSync",
      type: GRPCCallType.unary
    )

    internal static let addInvoice = GRPCMethodDescriptor(
      name: "AddInvoice",
      path: "/lnrpc.Lightning/AddInvoice",
      type: GRPCCallType.unary
    )

    internal static let listInvoices = GRPCMethodDescriptor(
      name: "ListInvoices",
      path: "/lnrpc.Lightning/ListInvoices",
      type: GRPCCallType.unary
    )

    internal static let lookupInvoice = GRPCMethodDescriptor(
      name: "LookupInvoice",
      path: "/lnrpc.Lightning/LookupInvoice",
      type: GRPCCallType.unary
    )

    internal static let subscribeInvoices = GRPCMethodDescriptor(
      name: "SubscribeInvoices",
      path: "/lnrpc.Lightning/SubscribeInvoices",
      type: GRPCCallType.serverStreaming
    )

    internal static let decodePayReq = GRPCMethodDescriptor(
      name: "DecodePayReq",
      path: "/lnrpc.Lightning/DecodePayReq",
      type: GRPCCallType.unary
    )

    internal static let listPayments = GRPCMethodDescriptor(
      name: "ListPayments",
      path: "/lnrpc.Lightning/ListPayments",
      type: GRPCCallType.unary
    )

    internal static let deletePayment = GRPCMethodDescriptor(
      name: "DeletePayment",
      path: "/lnrpc.Lightning/DeletePayment",
      type: GRPCCallType.unary
    )

    internal static let deleteAllPayments = GRPCMethodDescriptor(
      name: "DeleteAllPayments",
      path: "/lnrpc.Lightning/DeleteAllPayments",
      type: GRPCCallType.unary
    )

    internal static let describeGraph = GRPCMethodDescriptor(
      name: "DescribeGraph",
      path: "/lnrpc.Lightning/DescribeGraph",
      type: GRPCCallType.unary
    )

    internal static let getNodeMetrics = GRPCMethodDescriptor(
      name: "GetNodeMetrics",
      path: "/lnrpc.Lightning/GetNodeMetrics",
      type: GRPCCallType.unary
    )

    internal static let getChanInfo = GRPCMethodDescriptor(
      name: "GetChanInfo",
      path: "/lnrpc.Lightning/GetChanInfo",
      type: GRPCCallType.unary
    )

    internal static let getNodeInfo = GRPCMethodDescriptor(
      name: "GetNodeInfo",
      path: "/lnrpc.Lightning/GetNodeInfo",
      type: GRPCCallType.unary
    )

    internal static let queryRoutes = GRPCMethodDescriptor(
      name: "QueryRoutes",
      path: "/lnrpc.Lightning/QueryRoutes",
      type: GRPCCallType.unary
    )

    internal static let getNetworkInfo = GRPCMethodDescriptor(
      name: "GetNetworkInfo",
      path: "/lnrpc.Lightning/GetNetworkInfo",
      type: GRPCCallType.unary
    )

    internal static let stopDaemon = GRPCMethodDescriptor(
      name: "StopDaemon",
      path: "/lnrpc.Lightning/StopDaemon",
      type: GRPCCallType.unary
    )

    internal static let subscribeChannelGraph = GRPCMethodDescriptor(
      name: "SubscribeChannelGraph",
      path: "/lnrpc.Lightning/SubscribeChannelGraph",
      type: GRPCCallType.serverStreaming
    )

    internal static let debugLevel = GRPCMethodDescriptor(
      name: "DebugLevel",
      path: "/lnrpc.Lightning/DebugLevel",
      type: GRPCCallType.unary
    )

    internal static let feeReport = GRPCMethodDescriptor(
      name: "FeeReport",
      path: "/lnrpc.Lightning/FeeReport",
      type: GRPCCallType.unary
    )

    internal static let updateChannelPolicy = GRPCMethodDescriptor(
      name: "UpdateChannelPolicy",
      path: "/lnrpc.Lightning/UpdateChannelPolicy",
      type: GRPCCallType.unary
    )

    internal static let forwardingHistory = GRPCMethodDescriptor(
      name: "ForwardingHistory",
      path: "/lnrpc.Lightning/ForwardingHistory",
      type: GRPCCallType.unary
    )

    internal static let exportChannelBackup = GRPCMethodDescriptor(
      name: "ExportChannelBackup",
      path: "/lnrpc.Lightning/ExportChannelBackup",
      type: GRPCCallType.unary
    )

    internal static let exportAllChannelBackups = GRPCMethodDescriptor(
      name: "ExportAllChannelBackups",
      path: "/lnrpc.Lightning/ExportAllChannelBackups",
      type: GRPCCallType.unary
    )

    internal static let verifyChanBackup = GRPCMethodDescriptor(
      name: "VerifyChanBackup",
      path: "/lnrpc.Lightning/VerifyChanBackup",
      type: GRPCCallType.unary
    )

    internal static let restoreChannelBackups = GRPCMethodDescriptor(
      name: "RestoreChannelBackups",
      path: "/lnrpc.Lightning/RestoreChannelBackups",
      type: GRPCCallType.unary
    )

    internal static let subscribeChannelBackups = GRPCMethodDescriptor(
      name: "SubscribeChannelBackups",
      path: "/lnrpc.Lightning/SubscribeChannelBackups",
      type: GRPCCallType.serverStreaming
    )

    internal static let bakeMacaroon = GRPCMethodDescriptor(
      name: "BakeMacaroon",
      path: "/lnrpc.Lightning/BakeMacaroon",
      type: GRPCCallType.unary
    )

    internal static let listMacaroonIDs = GRPCMethodDescriptor(
      name: "ListMacaroonIDs",
      path: "/lnrpc.Lightning/ListMacaroonIDs",
      type: GRPCCallType.unary
    )

    internal static let deleteMacaroonID = GRPCMethodDescriptor(
      name: "DeleteMacaroonID",
      path: "/lnrpc.Lightning/DeleteMacaroonID",
      type: GRPCCallType.unary
    )

    internal static let listPermissions = GRPCMethodDescriptor(
      name: "ListPermissions",
      path: "/lnrpc.Lightning/ListPermissions",
      type: GRPCCallType.unary
    )

    internal static let checkMacaroonPermissions = GRPCMethodDescriptor(
      name: "CheckMacaroonPermissions",
      path: "/lnrpc.Lightning/CheckMacaroonPermissions",
      type: GRPCCallType.unary
    )

    internal static let registerRPCMiddleware = GRPCMethodDescriptor(
      name: "RegisterRPCMiddleware",
      path: "/lnrpc.Lightning/RegisterRPCMiddleware",
      type: GRPCCallType.bidirectionalStreaming
    )

    internal static let sendCustomMessage = GRPCMethodDescriptor(
      name: "SendCustomMessage",
      path: "/lnrpc.Lightning/SendCustomMessage",
      type: GRPCCallType.unary
    )

    internal static let subscribeCustomMessages = GRPCMethodDescriptor(
      name: "SubscribeCustomMessages",
      path: "/lnrpc.Lightning/SubscribeCustomMessages",
      type: GRPCCallType.serverStreaming
    )

    internal static let listAliases = GRPCMethodDescriptor(
      name: "ListAliases",
      path: "/lnrpc.Lightning/ListAliases",
      type: GRPCCallType.unary
    )

    internal static let lookupHtlcResolution = GRPCMethodDescriptor(
      name: "LookupHtlcResolution",
      path: "/lnrpc.Lightning/LookupHtlcResolution",
      type: GRPCCallType.unary
    )
  }
}
